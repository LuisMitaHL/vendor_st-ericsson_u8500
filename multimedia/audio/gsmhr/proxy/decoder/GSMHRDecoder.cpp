/*
 * Copyright (C) ST-Ericsson SA 2010. All rights reserved.
 * This code is ST-Ericsson proprietary and confidential.
 * Any use of the code for whatever purpose is subject to
 * specific written permission of ST-Ericsson SA.
 */

#include "GSMHRDecoder.h"
#include "GSMHRDec_BitstreamPort.h"
#include "GSMHRNmfHost_Decoder.h"
#include "GSMHRDec_PcmPort.h"

// UID top dictionnary (generated by trace compiler)
#include "GSMHR_HOST_DEC_top.h"
// TODO FIXME: manage buffers that are not 32-bit multiple  (for Host proxy only)
#define SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES 4 


OMX_ERRORTYPE gsmhrhostdecFactoryMethod(ENS_Component_p * ppENSComponent) {
    OMX_ERRORTYPE error  = OMX_ErrorNone;

    GSMHRDecoder *gsmhrdec = new GSMHRDecoder(true);
    if (gsmhrdec == 0) {
        return OMX_ErrorInsufficientResources;
    }

    error = gsmhrdec->construct();

    if (error != OMX_ErrorNone) {
        delete gsmhrdec;
        *ppENSComponent = 0;
        return OMX_ErrorInsufficientResources;
    } else {
        *ppENSComponent = gsmhrdec;
    }

    GSMHRNmfHost_Decoder *gsmhrdec_ProcessingComp = new GSMHRNmfHost_Decoder(*gsmhrdec);

    if (gsmhrdec_ProcessingComp == 0) {
        delete gsmhrdec;
        return OMX_ErrorInsufficientResources;
    }

    gsmhrdec->setProcessingComponent(gsmhrdec_ProcessingComp);

    return error;
}

OMX_ERRORTYPE GSMHRDecoder::createGSMHRBitstreamPort(const OMX_AUDIO_PARAM_GSMHRTYPE &defaultGsmhrSettings)
{
  OMX_U32 supported_length = getMaxFrameSize()/8;

  if (mIsHost) {
    supported_length += (SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES - 1);
    supported_length &= ~(SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES - 1);
  }

    GSMHRDec_BitstreamPort *gsmhrPort = 
      new GSMHRDec_BitstreamPort(0, OMX_DirInput, supported_length, defaultGsmhrSettings, *this); 

    if (gsmhrPort == 0) {
        return OMX_ErrorInsufficientResources;
    }

    addPort(gsmhrPort);
    

   	gsmhrPort->setSupportedProprietaryComm(AFM_HOST_PROPRIETARY_COMMUNICATION);

    	

    return OMX_ErrorNone;
}

OMX_ERRORTYPE  GSMHRDecoder::construct()
{
    OMX_ERRORTYPE error;
    OMX_AUDIO_PARAM_PCMMODETYPE defaultPcmSettings;
    OMX_AUDIO_PARAM_GSMHRTYPE defaultGsmhrSettings;

    defaultPcmSettings.nPortIndex     = 1;
    defaultPcmSettings.eNumData       = OMX_NumericalDataSigned;
    defaultPcmSettings.eEndian        = OMX_EndianLittle;
    defaultPcmSettings.bInterleaved   = OMX_TRUE;
    defaultPcmSettings.ePCMMode       = OMX_AUDIO_PCMModeLinear;
    defaultPcmSettings.nBitPerSample  = 16;

    defaultPcmSettings.nChannels      = 1;
    defaultPcmSettings.nSamplingRate  = 8000;

    defaultPcmSettings.eChannelMapping[0] = OMX_AUDIO_ChannelCF;

    defaultGsmhrSettings.nSize         = sizeof(OMX_AUDIO_PARAM_GSMHRTYPE);
    getOmxIlSpecVersion(&defaultGsmhrSettings.nVersion);
    defaultGsmhrSettings.nPortIndex      = 0;
    defaultGsmhrSettings.bDTX            = OMX_FALSE;
    defaultGsmhrSettings.bHiPassFilter   = OMX_TRUE;

    error = AFM_Decoder::construct(
            OMX_AUDIO_CodingGSMHR, getSampleFrameSize()*getMaxChannels(), defaultPcmSettings, 1);
    if (error != OMX_ErrorNone) return error;

    ENS_String<16> role = "audio_decoder.gsmhr";
    role.put((OMX_STRING)mRoles[0]);
    setActiveRole(mRoles[0]);
    
    error = createGSMHRBitstreamPort(defaultGsmhrSettings);
    if (error != OMX_ErrorNone) return error;

    AFM_PcmPort *pcmPort = static_cast<AFM_PcmPort *>(getPort(1));
    pcmPort->setSupportedProprietaryComm(AFM_HOST_PROPRIETARY_COMMUNICATION);
    return OMX_ErrorNone;
}

OMX_ERRORTYPE GSMHRDecoder::getExtensionIndex(OMX_STRING cParameterName,
						     OMX_INDEXTYPE* pIndexType) const
{
        if (ENS_String<ENS_COMPONENT_NAME_MAX_LENGTH>(cParameterName) 
                == "OMX.ST.AFM.proprietary_communication") {
            return OMX_ErrorNotImplemented;
        }

    return AFM_Component::getExtensionIndex(cParameterName, pIndexType);
}

OMX_ERRORTYPE GSMHRDecoder::createPcmPort(
        OMX_U32 nIndex,
        OMX_DIRTYPE eDir,
        OMX_U32 nBufferSizeMin,
        const OMX_AUDIO_PARAM_PCMMODETYPE &defaultPcmSettings)
{
    ENS_Port * port = new GSMHRDec_PcmPort(
                nIndex, eDir, nBufferSizeMin, defaultPcmSettings, *this);
    if (port == 0) {
        return OMX_ErrorInsufficientResources;
    }

    addPort(port);

    return OMX_ErrorNone;
}
OMX_U32 GSMHRDecoder::getUidTopDictionnary(void)
{
    return KOstGSMHR_HOST_DEC_top_ID;
}
