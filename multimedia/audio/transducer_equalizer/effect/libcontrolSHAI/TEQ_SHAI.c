/*****************************************************************************/
/*
 * Copyright (C) ST-Ericsson SA 2009,2010. All rights reserved.
 * This code is ST-Ericsson proprietary and confidential.
 * Any use of the code for whatever purpose is subject to
 * specific written permission of ST-Ericsson SA.
 *
 */

/**
 * \file   TEQ_SHAI.c
 * \brief
 * \author ST-Ericsson
 */
/*****************************************************************************/

#if defined(MATLAB_TEQ_SHAI_CONFIG) || (DEBUG_TEQ_SHAI_CONFIG_LEVEL > 0)
#include <assert.h>
#else // MATLAB_TEQ_SHAI_CONFIG || (DEBUG_TEQ_SHAI_CONFIG_LEVEL > 0)
#define assert(a)
#endif // MATLAB_TEQ_SHAI_CONFIG || (DEBUG_TEQ_SHAI_CONFIG_LEVEL > 0)

#include <stdlib.h>
#include "TEQ_SHAI.h"


//#define DEBUG_MALLOC

#ifdef DEBUG_MALLOC

#include <stdio.h>

typedef struct
{
    void   *ptr;
    size_t size;
    int    line;
} t_debug_malloc;
#define NB_MAX_MALLOC 1000

static t_debug_malloc debug_malloc_table[NB_MAX_MALLOC];
static int            init_debug_malloc = 1;

static void *debug_malloc(size_t size, int line)
{
    int  i;
    void *ptr;

    if(init_debug_malloc)
    {
        for(i = 0; i < NB_MAX_MALLOC; i++)
        {
            debug_malloc_table[i].ptr = NULL;
        }
        init_debug_malloc = 0;
    }

    ptr = malloc(size);
    if(ptr != NULL)
    {
        for(i = 0; i < NB_MAX_MALLOC; i++)
        {
            if(debug_malloc_table[i].ptr == NULL)
            {
                debug_malloc_table[i].ptr  = ptr;
                debug_malloc_table[i].size = size;
                debug_malloc_table[i].line = line;
                break;
            }
        }
        if(i == NB_MAX_MALLOC)
        {
            printf("\n*** debug_malloc_table size too small ***\n\n");
        }
    }
    return ptr;
}


static void debug_free(void *ptr, int line)
{
    int i;

    if(init_debug_malloc)
    {
        for(i = 0; i < NB_MAX_MALLOC; i++)
        {
            debug_malloc_table[i].ptr = NULL;
        }
        init_debug_malloc = 0;
    }

    if(ptr != NULL)
    {
        for(i = 0; i < NB_MAX_MALLOC; i++)
        {
            if(debug_malloc_table[i].ptr == ptr)
            {
                debug_malloc_table[i].ptr = NULL;
                break;
            }
        }
        if(i == NB_MAX_MALLOC)
        {
            printf("\n*** can't find malloc address 0x%08X in line %d ***\n\n", (int) ptr, line);
        }
    }

    free(ptr);
}

static void debug_check_free(void)
{
    int i;

    for(i = 0; i < NB_MAX_MALLOC; i++)
    {
        if(debug_malloc_table[i].ptr != NULL)
        {
            printf("\n*** line %d : malloc(%d), address 0x%08X not freed ***\n", debug_malloc_table[i].line, debug_malloc_table[i].size, (int) debug_malloc_table[i].ptr);
        }
    }
}

#define my_malloc(size) debug_malloc(size, __LINE__)
#define my_free(ptr)    debug_free(ptr, __LINE__)
#define my_check_free   debug_check_free();

#else // DEBUG_MALLOC

#define my_malloc(size) malloc(size)
#define my_free(ptr)    free(ptr)
#define my_check_free

#endif // DEBUG_MALLOC



#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 0
FILE *debug_TEQ_SHAI_file[NB_MAX_INSTANCE_TEQ] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};

void open_debug_TEQ_SHAI_file(int instance)
{
    assert(instance < NB_MAX_INSTANCE_TEQ);

    if(debug_TEQ_SHAI_file[instance] == NULL)
    {
        char filename[100];

        sprintf(filename, "debug_TEQ_SHAI_%d.txt", instance);
        debug_TEQ_SHAI_file[instance] = fopen(filename, "w");
        if(debug_TEQ_SHAI_file[instance] == NULL)
        {
            printf("can't open %s file !!!\n", filename);
            exit(-1);
        }
    }
}

void write0_debug_TEQ_SHAI_file(int instance, const char *format)
{
    assert(instance < NB_MAX_INSTANCE_TEQ);

    if(debug_TEQ_SHAI_file[instance] != NULL)
    {
        fprintf(debug_TEQ_SHAI_file[instance], "%s", format);
    }
}

void write1_debug_TEQ_SHAI_file(int instance, const char *format, int val1)
{
    assert(instance < NB_MAX_INSTANCE_TEQ);

    if(debug_TEQ_SHAI_file[instance] != NULL)
    {
        char string[200];

        sprintf(string, format, val1);
        fprintf(debug_TEQ_SHAI_file[instance], "%s", string);
    }
}

void write2_debug_TEQ_SHAI_file(int instance, const char *format, int val1, int val2)
{
    assert(instance < NB_MAX_INSTANCE_TEQ);

    if(debug_TEQ_SHAI_file[instance] != NULL)
    {
        char string[200];

        sprintf(string, format, val1, val2);
        fprintf(debug_TEQ_SHAI_file[instance], "%s", string);
    }
}

void close_debug_TEQ_SHAI_file(int instance)
{
    assert(instance < NB_MAX_INSTANCE_TEQ);

    if(debug_TEQ_SHAI_file[instance] != NULL)
    {
        fclose(debug_TEQ_SHAI_file[instance]);
        debug_TEQ_SHAI_file[instance] = NULL;
    }
}
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 0


#ifdef MATLAB_TEQ_SHAI_CONFIG
FILE *matlab_TEQ_SHAI_file[NB_MAX_INSTANCE_TEQ] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};

void open_matlab_TEQ_SHAI_file(int instance)
{
    assert(instance < NB_MAX_INSTANCE_TEQ);

    if(matlab_TEQ_SHAI_file[instance] == NULL)
    {
        char filename[100];

        sprintf(filename, "matlab_TEQ_SHAI_%d.m", instance);
        matlab_TEQ_SHAI_file[instance] = fopen(filename, "w");
        if(matlab_TEQ_SHAI_file[instance] == NULL)
        {
            printf("can't open %s file !!!\n", filename);
            exit(-1);
        }
    }
}

void close_matlab_TEQ_SHAI_file(int instance)
{
    assert(instance < NB_MAX_INSTANCE_TEQ);

    if(matlab_TEQ_SHAI_file[instance] != NULL)
    {
        fclose(matlab_TEQ_SHAI_file[instance]);
        matlab_TEQ_SHAI_file[instance] = NULL;
    }
}
#endif // MATLAB_TEQ_SHAI_CONFIG


static const t_float pow2_float[32] =
{
           1.0,        2.0,        4.0,         8.0,        16.0,        32.0,         64.0,        128.0,
         256.0,      512.0,     1024.0,      2048.0,      4096.0,      8192.0,      16384.0,      32768.0,
       65536.0,   131072.0,   262144.0,    524288.0,   1048576.0,   2097152.0,    4194304.0,    8388608.0,
    16777216.0, 33554432.0, 67108864.0, 134217728.0, 268435456.0, 536870912.0, 1073741824.0, 2147483648.0
};

static const int max_float[32] =
{
           0.0,        1.0,        3.0,         7.0,        15.0,        31.0,         63.0,        127.0,
         255.0,      511.0,     1023.0,      2047.0,      4095.0,      8191.0,      16383.0,      32767.0,
       65535.0,   131071.0,   262143.0,    524287.0,   1048575.0,   2097151.0,    4194303.0,    8388607.0,
    16777215.0, 33554431.0, 67108863.0, 134217727.0, 268435455.0, 536870911.0, 1073741823.0, 2147483647.0
};

static const int max_int_Q31[32] =
{
           0 << 31,        1 << 30,        3 << 29,         7 << 28,        15 << 27,        31 << 26,         63 << 25,        127 << 24,
         255 << 23,      511 << 22,     1023 << 21,      2047 << 20,      4095 << 19,      8191 << 18,      16383 << 17,      32767 << 16,
       65535 << 15,   131071 << 14,   262143 << 13,    524287 << 12,   1048575 << 11,   2097151 << 10,    4194303 <<  9,    8388607 <<  8,
    16777215 <<  7, 33554431 <<  6, 67108863 <<  5, 134217727 <<  4, 268435455 <<  3, 536870911 <<  2, 1073741823 <<  1, 2147483647 <<  0
};

OMX_S32 float2Q31(t_float x, int nb_bits_quantif)
{
    int shift = 32 - nb_bits_quantif;

    if(x > 0.0)
    {
        x *= pow2_float[nb_bits_quantif - 1];
        if(x > max_float[nb_bits_quantif - 1])
        {
            return (OMX_S32) max_int_Q31[nb_bits_quantif - 1];
        }
        else
        {
            return (OMX_S32) (((int) Floor(x + 0.5)) << shift);
        }
    }
    else
    {
        if(x < -1.0)
        {
            return (OMX_S32) 0x80000000;
        }
        else
        {
            return (OMX_S32) (((int) Ceil(x * pow2_float[nb_bits_quantif - 1] - 0.5)) << shift);
        }
    }
}


void mult_gains(OMX_S32 *p_gain_mant, OMX_S16 *p_gain_exp, OMX_S32 gain_mB, int nb_bits_quantif)
{
    t_float prod = ((t_float) *p_gain_mant) * Pow2(*p_gain_exp - 31) * Pow10(((t_float) gain_mB) / 2000.0);

    if(prod == 0.0)
    {
        *p_gain_mant = 0;
        *p_gain_exp  = 0;
    }
    else
    {
        t_float sign = 1.0;
        t_float tmp;
        int     shift;

        if(prod < 0.0)
        {
            sign = -1.0;
            prod = -prod;
        }

        shift = 0;
        tmp   = prod * pow2_float[nb_bits_quantif - 1] / max_float[nb_bits_quantif - 1];
        while(tmp > 1.0)
        {
            prod *= 0.5;
            tmp  *= 0.5;
            shift++;
        }
        while(tmp <= 0.5)
        {
            prod *= 2.0;
            tmp  *= 2.0;
            shift--;
        }
        *p_gain_mant = float2Q31(sign * prod, nb_bits_quantif);
        *p_gain_exp  = (OMX_S16) shift;
    }
}



#define COS_TABLE_SIZE 2048

static const t_float cos_table[COS_TABLE_SIZE] =
{
     1.000000000000000,  0.999995293809576,  0.999981175282601,  0.999957644551964,  0.999924701839145,  0.999882347454213,  0.999830581795823,  0.999769405351215,
     0.999698818696204,  0.999618822495179,  0.999529417501093,  0.999430604555462,  0.999322384588350,  0.999204758618364,  0.999077727752645,  0.998941293186857,
     0.998795456205172,  0.998640218180265,  0.998475580573295,  0.998301544933893,  0.998118112900149,  0.997925286198596,  0.997723066644192,  0.997511456140303,
     0.997290456678690,  0.997060070339483,  0.996820299291166,  0.996571145790555,  0.996312612182778,  0.996044700901252,  0.995767414467660,  0.995480755491927,
     0.995184726672197,  0.994879330794806,  0.994564570734255,  0.994240449453188,  0.993906970002356,  0.993564135520595,  0.993211949234795,  0.992850414459865,
     0.992479534598710,  0.992099313142192,  0.991709753669100,  0.991310859846115,  0.990902635427780,  0.990485084256457,  0.990058210262297,  0.989622017463201,
     0.989176509964781,  0.988721691960324,  0.988257567730749,  0.987784141644572,  0.987301418157858,  0.986809401814186,  0.986308097244599,  0.985797509167567,
     0.985277642388941,  0.984748501801904,  0.984210092386929,  0.983662419211730,  0.983105487431216,  0.982539302287441,  0.981963869109555,  0.981379193313755,
     0.980785280403230,  0.980182135968117,  0.979569765685441,  0.978948175319062,  0.978317370719628,  0.977677357824510,  0.977028142657754,  0.976369731330021,
     0.975702130038529,  0.975025345066994,  0.974339382785576,  0.973644249650812,  0.972939952205560,  0.972226497078936,  0.971503890986252,  0.970772140728950,
     0.970031253194544,  0.969281235356549,  0.968522094274417,  0.967753837093476,  0.966976471044852,  0.966190003445413,  0.965394441697689,  0.964589793289813,
     0.963776065795440,  0.962953266873684,  0.962121404269042,  0.961280485811321,  0.960430519415566,  0.959571513081985,  0.958703474895872,  0.957826413027533,
     0.956940335732209,  0.956045251349996,  0.955141168305771,  0.954228095109106,  0.953306040354194,  0.952375012719766,  0.951435020969008,  0.950486073949482,
     0.949528180593037,  0.948561349915730,  0.947585591017741,  0.946600913083284,  0.945607325380521,  0.944604837261480,  0.943593458161960,  0.942573197601447,
     0.941544065183021,  0.940506070593268,  0.939459223602190,  0.938403534063108,  0.937339011912575,  0.936265667170278,  0.935183509938948,  0.934092550404259,
     0.932992798834739,  0.931884265581668,  0.930766961078984,  0.929640895843181,  0.928506080473216,  0.927362525650401,  0.926210242138311,  0.925049240782678,
     0.923879532511287,  0.922701128333879,  0.921514039342042,  0.920318276709111,  0.919113851690058,  0.917900775621391,  0.916679059921043,  0.915448716088268,
     0.914209755703531,  0.912962190428398,  0.911706032005430,  0.910441292258067,  0.909167983090522,  0.907886116487666,  0.906595704514915,  0.905296759318119,
     0.903989293123443,  0.902673318237259,  0.901348847046022,  0.900015892016160,  0.898674465693954,  0.897324580705418,  0.895966249756185,  0.894599485631383,
     0.893224301195515,  0.891840709392343,  0.890448723244758,  0.889048355854665,  0.887639620402854,  0.886222530148881,  0.884797098430938,  0.883363338665732,
     0.881921264348355,  0.880470889052161,  0.879012226428634,  0.877545290207261,  0.876070094195407,  0.874586652278176,  0.873094978418290,  0.871595086655951,
     0.870086991108711,  0.868570705971341,  0.867046245515693,  0.865513624090569,  0.863972856121587,  0.862423956111041,  0.860866938637767,  0.859301818357008,
     0.857728610000272,  0.856147328375194,  0.854557988365401,  0.852960604930364,  0.851355193105265,  0.849741768000853,  0.848120344803297,  0.846490938774052,
     0.844853565249707,  0.843208239641845,  0.841554977436898,  0.839893794196000,  0.838224705554838,  0.836547727223512,  0.834862874986380,  0.833170164701913,
     0.831469612302545,  0.829761233794523,  0.828045045257756,  0.826321062845664,  0.824589302785025,  0.822849781375826,  0.821102514991105,  0.819347520076797,
     0.817584813151584,  0.815814410806734,  0.814036329705948,  0.812250586585204,  0.810457198252595,  0.808656181588175,  0.806847553543799,  0.805031331142964,
     0.803207531480645,  0.801376171723140,  0.799537269107905,  0.797690840943391,  0.795836904608884,  0.793975477554337,  0.792106577300212,  0.790230221437310,
     0.788346427626606,  0.786455213599086,  0.784556597155575,  0.782650596166576,  0.780737228572094,  0.778816512381476,  0.776888465673232,  0.774953106594874,
     0.773010453362737,  0.771060524261814,  0.769103337645580,  0.767138911935820,  0.765167265622459,  0.763188417263381,  0.761202385484262,  0.759209188978388,
     0.757208846506485,  0.755201376896537,  0.753186799043613,  0.751165131909686,  0.749136394523459,  0.747100605980180,  0.745057785441466,  0.743007952135122,
     0.740951125354959,  0.738887324460615,  0.736816568877370,  0.734738878095964,  0.732654271672413,  0.730562769227828,  0.728464390448225,  0.726359155084346,
     0.724247082951467,  0.722128193929215,  0.720002507961382,  0.717870045055732,  0.715730825283819,  0.713584868780794,  0.711432195745216,  0.709272826438866,
     0.707106781186548,  0.704934080375905,  0.702754744457225,  0.700568793943248,  0.698376249408973,  0.696177131491463,  0.693971460889654,  0.691759258364158,
     0.689540544737067,  0.687315340891759,  0.685083667772700,  0.682845546385248,  0.680600997795453,  0.678350043129862,  0.676092703575316,  0.673829000378756,
     0.671558954847018,  0.669282588346636,  0.666999922303637,  0.664710978203345,  0.662415777590172,  0.660114342067420,  0.657806693297079,  0.655492852999615,
     0.653172842953777,  0.650846684996381,  0.648514401022113,  0.646176012983316,  0.643831542889792,  0.641481012808583,  0.639124444863776,  0.636761861236284,
     0.634393284163645,  0.632018735939809,  0.629638238914927,  0.627251815495144,  0.624859488142386,  0.622461279374150,  0.620057211763289,  0.617647307937804,
     0.615231590580627,  0.612810082429410,  0.610382806276309,  0.607949784967774,  0.605511041404326,  0.603066598540348,  0.600616479383869,  0.598160706996342,
     0.595699304492433,  0.593232295039800,  0.590759701858874,  0.588281548222645,  0.585797857456439,  0.583308652937698,  0.580813958095765,  0.578313796411656,
     0.575808191417845,  0.573297166698042,  0.570780745886967,  0.568258952670131,  0.565731810783613,  0.563199344013834,  0.560661576197336,  0.558118531220556,
     0.555570233019602,  0.553016705580028,  0.550457972936605,  0.547894059173100,  0.545324988422046,  0.542750784864516,  0.540171472729893,  0.537587076295646,
     0.534997619887097,  0.532403127877198,  0.529803624686295,  0.527199134781901,  0.524589682678469,  0.521975292937154,  0.519355990165590,  0.516731799017650,
     0.514102744193222,  0.511468850437971,  0.508830142543107,  0.506186645345155,  0.503538383725718,  0.500885382611241,  0.498227666972782,  0.495565261825772,
     0.492898192229784,  0.490226483288291,  0.487550160148436,  0.484869248000791,  0.482183772079123,  0.479493757660153,  0.476799230063322,  0.474100214650550,
     0.471396736825998,  0.468688822035828,  0.465976495767966,  0.463259783551860,  0.460538710958240,  0.457813303598877,  0.455083587126344,  0.452349587233771,
     0.449611329654607,  0.446868840162374,  0.444122144570429,  0.441371268731717,  0.438616238538528,  0.435857079922255,  0.433093818853152,  0.430326481340083,
     0.427555093430282,  0.424779681209109,  0.422000270799800,  0.419216888363224,  0.416429560097637,  0.413638312238435,  0.410843171057904,  0.408044162864979,
     0.405241314004990,  0.402434650859419,  0.399624199845647,  0.396809987416710,  0.393992040061048,  0.391170384302254,  0.388345046698826,  0.385516053843919,
     0.382683432365090,  0.379847208924051,  0.377007410216418,  0.374164062971458,  0.371317193951838,  0.368466829953372,  0.365612997804774,  0.362755724367397,
     0.359895036534988,  0.357030961233430,  0.354163525420491,  0.351292756085567,  0.348418680249435,  0.345541324963989,  0.342660717311994,  0.339776884406827,
     0.336889853392220,  0.333999651442009,  0.331106305759876,  0.328209843579093,  0.325310292162263,  0.322407678801070,  0.319502030816016,  0.316593375556166,
     0.313681740398892,  0.310767152749611,  0.307849640041535,  0.304929229735402,  0.302005949319228,  0.299079826308040,  0.296150888243624,  0.293219162694259,
     0.290284677254462,  0.287347459544730,  0.284407537211272,  0.281464937925758,  0.278519689385053,  0.275571819310958,  0.272621355449949,  0.269668325572915,
     0.266712757474898,  0.263754678974832,  0.260794117915276,  0.257831102162159,  0.254865659604515,  0.251897818154217,  0.248927605745720,  0.245955050335795,
     0.242980179903264,  0.240003022448742,  0.237023605994367,  0.234041958583543,  0.231058108280671,  0.228072083170886,  0.225083911359793,  0.222093620973204,
     0.219101240156870,  0.216106797076220,  0.213110319916091,  0.210111836880470,  0.207111376192219,  0.204108966092817,  0.201104634842092,  0.198098410717954,
     0.195090322016128,  0.192080397049892,  0.189068664149806,  0.186055151663447,  0.183039887955141,  0.180022901405700,  0.177004220412149,  0.173983873387464,
     0.170961888760301,  0.167938294974731,  0.164913120489970,  0.161886393780112,  0.158858143333861,  0.155828397654265,  0.152797185258443,  0.149764534677322,
     0.146730474455362,  0.143695033150295,  0.140658239332849,  0.137620121586486,  0.134580708507126,  0.131540028702883,  0.128498110793793,  0.125454983411546,
     0.122410675199216,  0.119365214810991,  0.116318630911905,  0.113270952177564,  0.110222207293883,  0.107172424956809,  0.104121633872055,  0.101069862754828,
     0.098017140329561,  0.094963495329639,  0.091908956497133,  0.088853552582525,  0.085797312344440,  0.082740264549376,  0.079682437971430,  0.076623861392032,
     0.073564563599667,  0.070504573389614,  0.067443919563664,  0.064382630929857,  0.061320736302209,  0.058258264500436,  0.055195244349690,  0.052131704680283,
     0.049067674327418,  0.046003182130915,  0.042938256934941,  0.039872927587740,  0.036807222941359,  0.033741171851378,  0.030674803176637,  0.027608145778966,
     0.024541228522912,  0.021474080275470,  0.018406729905805,  0.015339206284988,  0.012271538285720,  0.009203754782060,  0.006135884649155,  0.003067956762966,
     0.000000000000000, -0.003067956762966, -0.006135884649154, -0.009203754782060, -0.012271538285720, -0.015339206284988, -0.018406729905805, -0.021474080275469,
    -0.024541228522912, -0.027608145778966, -0.030674803176636, -0.033741171851378, -0.036807222941359, -0.039872927587740, -0.042938256934941, -0.046003182130915,
    -0.049067674327418, -0.052131704680283, -0.055195244349690, -0.058258264500436, -0.061320736302209, -0.064382630929857, -0.067443919563664, -0.070504573389614,
    -0.073564563599667, -0.076623861392032, -0.079682437971430, -0.082740264549376, -0.085797312344440, -0.088853552582525, -0.091908956497133, -0.094963495329639,
    -0.098017140329561, -0.101069862754828, -0.104121633872055, -0.107172424956809, -0.110222207293883, -0.113270952177564, -0.116318630911905, -0.119365214810991,
    -0.122410675199216, -0.125454983411546, -0.128498110793793, -0.131540028702883, -0.134580708507126, -0.137620121586486, -0.140658239332849, -0.143695033150294,
    -0.146730474455362, -0.149764534677322, -0.152797185258443, -0.155828397654265, -0.158858143333861, -0.161886393780112, -0.164913120489970, -0.167938294974731,
    -0.170961888760301, -0.173983873387464, -0.177004220412149, -0.180022901405699, -0.183039887955141, -0.186055151663446, -0.189068664149806, -0.192080397049892,
    -0.195090322016128, -0.198098410717954, -0.201104634842092, -0.204108966092817, -0.207111376192218, -0.210111836880470, -0.213110319916091, -0.216106797076219,
    -0.219101240156870, -0.222093620973203, -0.225083911359793, -0.228072083170886, -0.231058108280671, -0.234041958583543, -0.237023605994367, -0.240003022448741,
    -0.242980179903264, -0.245955050335794, -0.248927605745720, -0.251897818154217, -0.254865659604515, -0.257831102162159, -0.260794117915275, -0.263754678974831,
    -0.266712757474898, -0.269668325572915, -0.272621355449949, -0.275571819310958, -0.278519689385053, -0.281464937925758, -0.284407537211272, -0.287347459544729,
    -0.290284677254462, -0.293219162694259, -0.296150888243624, -0.299079826308040, -0.302005949319228, -0.304929229735402, -0.307849640041535, -0.310767152749611,
    -0.313681740398891, -0.316593375556166, -0.319502030816016, -0.322407678801070, -0.325310292162263, -0.328209843579093, -0.331106305759876, -0.333999651442009,
    -0.336889853392220, -0.339776884406827, -0.342660717311994, -0.345541324963989, -0.348418680249434, -0.351292756085567, -0.354163525420490, -0.357030961233430,
    -0.359895036534988, -0.362755724367397, -0.365612997804774, -0.368466829953372, -0.371317193951837, -0.374164062971458, -0.377007410216418, -0.379847208924051,
    -0.382683432365090, -0.385516053843919, -0.388345046698826, -0.391170384302254, -0.393992040061048, -0.396809987416710, -0.399624199845647, -0.402434650859418,
    -0.405241314004990, -0.408044162864979, -0.410843171057904, -0.413638312238434, -0.416429560097637, -0.419216888363224, -0.422000270799800, -0.424779681209109,
    -0.427555093430282, -0.430326481340083, -0.433093818853152, -0.435857079922255, -0.438616238538527, -0.441371268731717, -0.444122144570429, -0.446868840162374,
    -0.449611329654607, -0.452349587233771, -0.455083587126344, -0.457813303598877, -0.460538710958240, -0.463259783551860, -0.465976495767966, -0.468688822035828,
    -0.471396736825998, -0.474100214650550, -0.476799230063322, -0.479493757660153, -0.482183772079123, -0.484869248000791, -0.487550160148436, -0.490226483288291,
    -0.492898192229784, -0.495565261825772, -0.498227666972782, -0.500885382611241, -0.503538383725717, -0.506186645345155, -0.508830142543107, -0.511468850437970,
    -0.514102744193222, -0.516731799017650, -0.519355990165590, -0.521975292937154, -0.524589682678469, -0.527199134781901, -0.529803624686295, -0.532403127877198,
    -0.534997619887097, -0.537587076295646, -0.540171472729893, -0.542750784864516, -0.545324988422046, -0.547894059173100, -0.550457972936605, -0.553016705580027,
    -0.555570233019602, -0.558118531220556, -0.560661576197336, -0.563199344013834, -0.565731810783613, -0.568258952670131, -0.570780745886967, -0.573297166698042,
    -0.575808191417845, -0.578313796411655, -0.580813958095764, -0.583308652937698, -0.585797857456439, -0.588281548222645, -0.590759701858874, -0.593232295039800,
    -0.595699304492433, -0.598160706996342, -0.600616479383869, -0.603066598540348, -0.605511041404325, -0.607949784967774, -0.610382806276310, -0.612810082429410,
    -0.615231590580627, -0.617647307937804, -0.620057211763289, -0.622461279374150, -0.624859488142386, -0.627251815495144, -0.629638238914927, -0.632018735939809,
    -0.634393284163645, -0.636761861236284, -0.639124444863776, -0.641481012808583, -0.643831542889791, -0.646176012983316, -0.648514401022112, -0.650846684996381,
    -0.653172842953777, -0.655492852999615, -0.657806693297079, -0.660114342067420, -0.662415777590172, -0.664710978203345, -0.666999922303637, -0.669282588346636,
    -0.671558954847018, -0.673829000378756, -0.676092703575316, -0.678350043129861, -0.680600997795453, -0.682845546385248, -0.685083667772700, -0.687315340891759,
    -0.689540544737067, -0.691759258364158, -0.693971460889654, -0.696177131491463, -0.698376249408973, -0.700568793943248, -0.702754744457225, -0.704934080375905,
    -0.707106781186547, -0.709272826438865, -0.711432195745217, -0.713584868780794, -0.715730825283819, -0.717870045055732, -0.720002507961382, -0.722128193929215,
    -0.724247082951467, -0.726359155084346, -0.728464390448225, -0.730562769227827, -0.732654271672413, -0.734738878095964, -0.736816568877370, -0.738887324460615,
    -0.740951125354959, -0.743007952135122, -0.745057785441466, -0.747100605980180, -0.749136394523459, -0.751165131909686, -0.753186799043612, -0.755201376896536,
    -0.757208846506485, -0.759209188978388, -0.761202385484262, -0.763188417263381, -0.765167265622459, -0.767138911935820, -0.769103337645579, -0.771060524261814,
    -0.773010453362737, -0.774953106594874, -0.776888465673232, -0.778816512381476, -0.780737228572094, -0.782650596166576, -0.784556597155575, -0.786455213599086,
    -0.788346427626606, -0.790230221437310, -0.792106577300212, -0.793975477554337, -0.795836904608883, -0.797690840943391, -0.799537269107905, -0.801376171723140,
    -0.803207531480645, -0.805031331142963, -0.806847553543799, -0.808656181588175, -0.810457198252595, -0.812250586585204, -0.814036329705948, -0.815814410806734,
    -0.817584813151584, -0.819347520076797, -0.821102514991105, -0.822849781375826, -0.824589302785025, -0.826321062845664, -0.828045045257756, -0.829761233794523,
    -0.831469612302545, -0.833170164701913, -0.834862874986380, -0.836547727223512, -0.838224705554838, -0.839893794196000, -0.841554977436898, -0.843208239641845,
    -0.844853565249707, -0.846490938774052, -0.848120344803297, -0.849741768000853, -0.851355193105265, -0.852960604930364, -0.854557988365400, -0.856147328375194,
    -0.857728610000272, -0.859301818357008, -0.860866938637767, -0.862423956111041, -0.863972856121587, -0.865513624090569, -0.867046245515693, -0.868570705971341,
    -0.870086991108711, -0.871595086655951, -0.873094978418290, -0.874586652278176, -0.876070094195406, -0.877545290207261, -0.879012226428634, -0.880470889052161,
    -0.881921264348355, -0.883363338665732, -0.884797098430938, -0.886222530148881, -0.887639620402854, -0.889048355854665, -0.890448723244758, -0.891840709392343,
    -0.893224301195515, -0.894599485631383, -0.895966249756185, -0.897324580705418, -0.898674465693954, -0.900015892016160, -0.901348847046022, -0.902673318237259,
    -0.903989293123443, -0.905296759318119, -0.906595704514915, -0.907886116487666, -0.909167983090522, -0.910441292258067, -0.911706032005430, -0.912962190428398,
    -0.914209755703531, -0.915448716088268, -0.916679059921043, -0.917900775621391, -0.919113851690058, -0.920318276709110, -0.921514039342042, -0.922701128333879,
    -0.923879532511287, -0.925049240782677, -0.926210242138311, -0.927362525650401, -0.928506080473215, -0.929640895843181, -0.930766961078984, -0.931884265581668,
    -0.932992798834739, -0.934092550404259, -0.935183509938948, -0.936265667170278, -0.937339011912575, -0.938403534063108, -0.939459223602190, -0.940506070593268,
    -0.941544065183021, -0.942573197601447, -0.943593458161960, -0.944604837261480, -0.945607325380521, -0.946600913083284, -0.947585591017741, -0.948561349915730,
    -0.949528180593037, -0.950486073949482, -0.951435020969008, -0.952375012719766, -0.953306040354194, -0.954228095109106, -0.955141168305771, -0.956045251349996,
    -0.956940335732209, -0.957826413027533, -0.958703474895871, -0.959571513081985, -0.960430519415566, -0.961280485811321, -0.962121404269041, -0.962953266873684,
    -0.963776065795440, -0.964589793289813, -0.965394441697689, -0.966190003445413, -0.966976471044852, -0.967753837093475, -0.968522094274417, -0.969281235356548,
    -0.970031253194544, -0.970772140728950, -0.971503890986252, -0.972226497078936, -0.972939952205560, -0.973644249650812, -0.974339382785576, -0.975025345066994,
    -0.975702130038528, -0.976369731330021, -0.977028142657754, -0.977677357824510, -0.978317370719628, -0.978948175319062, -0.979569765685441, -0.980182135968117,
    -0.980785280403230, -0.981379193313755, -0.981963869109555, -0.982539302287441, -0.983105487431216, -0.983662419211730, -0.984210092386929, -0.984748501801904,
    -0.985277642388941, -0.985797509167567, -0.986308097244599, -0.986809401814186, -0.987301418157858, -0.987784141644572, -0.988257567730749, -0.988721691960324,
    -0.989176509964781, -0.989622017463201, -0.990058210262297, -0.990485084256457, -0.990902635427780, -0.991310859846115, -0.991709753669100, -0.992099313142192,
    -0.992479534598710, -0.992850414459865, -0.993211949234795, -0.993564135520595, -0.993906970002356, -0.994240449453188, -0.994564570734255, -0.994879330794806,
    -0.995184726672197, -0.995480755491927, -0.995767414467660, -0.996044700901252, -0.996312612182778, -0.996571145790555, -0.996820299291166, -0.997060070339483,
    -0.997290456678690, -0.997511456140303, -0.997723066644192, -0.997925286198596, -0.998118112900149, -0.998301544933893, -0.998475580573295, -0.998640218180265,
    -0.998795456205172, -0.998941293186857, -0.999077727752645, -0.999204758618364, -0.999322384588350, -0.999430604555462, -0.999529417501093, -0.999618822495179,
    -0.999698818696204, -0.999769405351215, -0.999830581795823, -0.999882347454213, -0.999924701839145, -0.999957644551964, -0.999981175282601, -0.999995293809576,
    -1.000000000000000, -0.999995293809576, -0.999981175282601, -0.999957644551964, -0.999924701839145, -0.999882347454213, -0.999830581795823, -0.999769405351215,
    -0.999698818696204, -0.999618822495179, -0.999529417501093, -0.999430604555462, -0.999322384588350, -0.999204758618364, -0.999077727752645, -0.998941293186857,
    -0.998795456205172, -0.998640218180265, -0.998475580573295, -0.998301544933893, -0.998118112900149, -0.997925286198596, -0.997723066644192, -0.997511456140303,
    -0.997290456678690, -0.997060070339483, -0.996820299291166, -0.996571145790555, -0.996312612182778, -0.996044700901252, -0.995767414467660, -0.995480755491927,
    -0.995184726672197, -0.994879330794806, -0.994564570734256, -0.994240449453188, -0.993906970002356, -0.993564135520595, -0.993211949234795, -0.992850414459865,
    -0.992479534598710, -0.992099313142192, -0.991709753669100, -0.991310859846115, -0.990902635427780, -0.990485084256457, -0.990058210262297, -0.989622017463201,
    -0.989176509964781, -0.988721691960324, -0.988257567730749, -0.987784141644572, -0.987301418157858, -0.986809401814186, -0.986308097244599, -0.985797509167567,
    -0.985277642388941, -0.984748501801904, -0.984210092386929, -0.983662419211730, -0.983105487431216, -0.982539302287441, -0.981963869109555, -0.981379193313755,
    -0.980785280403230, -0.980182135968117, -0.979569765685441, -0.978948175319062, -0.978317370719628, -0.977677357824510, -0.977028142657754, -0.976369731330021,
    -0.975702130038529, -0.975025345066994, -0.974339382785576, -0.973644249650812, -0.972939952205560, -0.972226497078936, -0.971503890986252, -0.970772140728950,
    -0.970031253194544, -0.969281235356549, -0.968522094274417, -0.967753837093476, -0.966976471044852, -0.966190003445413, -0.965394441697689, -0.964589793289813,
    -0.963776065795440, -0.962953266873684, -0.962121404269042, -0.961280485811321, -0.960430519415566, -0.959571513081985, -0.958703474895872, -0.957826413027533,
    -0.956940335732209, -0.956045251349996, -0.955141168305771, -0.954228095109106, -0.953306040354194, -0.952375012719766, -0.951435020969008, -0.950486073949482,
    -0.949528180593037, -0.948561349915730, -0.947585591017741, -0.946600913083284, -0.945607325380521, -0.944604837261480, -0.943593458161960, -0.942573197601447,
    -0.941544065183021, -0.940506070593268, -0.939459223602190, -0.938403534063108, -0.937339011912575, -0.936265667170278, -0.935183509938948, -0.934092550404259,
    -0.932992798834739, -0.931884265581668, -0.930766961078984, -0.929640895843181, -0.928506080473216, -0.927362525650401, -0.926210242138311, -0.925049240782678,
    -0.923879532511287, -0.922701128333879, -0.921514039342042, -0.920318276709111, -0.919113851690058, -0.917900775621391, -0.916679059921043, -0.915448716088268,
    -0.914209755703531, -0.912962190428398, -0.911706032005430, -0.910441292258067, -0.909167983090522, -0.907886116487666, -0.906595704514915, -0.905296759318119,
    -0.903989293123443, -0.902673318237259, -0.901348847046022, -0.900015892016160, -0.898674465693954, -0.897324580705418, -0.895966249756185, -0.894599485631383,
    -0.893224301195515, -0.891840709392343, -0.890448723244758, -0.889048355854665, -0.887639620402854, -0.886222530148881, -0.884797098430938, -0.883363338665732,
    -0.881921264348355, -0.880470889052161, -0.879012226428634, -0.877545290207261, -0.876070094195407, -0.874586652278176, -0.873094978418290, -0.871595086655951,
    -0.870086991108711, -0.868570705971341, -0.867046245515693, -0.865513624090569, -0.863972856121587, -0.862423956111041, -0.860866938637767, -0.859301818357008,
    -0.857728610000272, -0.856147328375195, -0.854557988365401, -0.852960604930364, -0.851355193105265, -0.849741768000853, -0.848120344803297, -0.846490938774052,
    -0.844853565249707, -0.843208239641845, -0.841554977436898, -0.839893794196000, -0.838224705554838, -0.836547727223512, -0.834862874986380, -0.833170164701913,
    -0.831469612302545, -0.829761233794523, -0.828045045257756, -0.826321062845664, -0.824589302785025, -0.822849781375826, -0.821102514991105, -0.819347520076797,
    -0.817584813151584, -0.815814410806734, -0.814036329705949, -0.812250586585204, -0.810457198252595, -0.808656181588175, -0.806847553543799, -0.805031331142964,
    -0.803207531480645, -0.801376171723140, -0.799537269107905, -0.797690840943391, -0.795836904608884, -0.793975477554337, -0.792106577300212, -0.790230221437310,
    -0.788346427626606, -0.786455213599086, -0.784556597155575, -0.782650596166576, -0.780737228572095, -0.778816512381476, -0.776888465673232, -0.774953106594874,
    -0.773010453362737, -0.771060524261814, -0.769103337645580, -0.767138911935821, -0.765167265622459, -0.763188417263381, -0.761202385484262, -0.759209188978388,
    -0.757208846506485, -0.755201376896537, -0.753186799043613, -0.751165131909687, -0.749136394523459, -0.747100605980180, -0.745057785441466, -0.743007952135122,
    -0.740951125354959, -0.738887324460615, -0.736816568877370, -0.734738878095964, -0.732654271672413, -0.730562769227828, -0.728464390448225, -0.726359155084346,
    -0.724247082951467, -0.722128193929215, -0.720002507961382, -0.717870045055732, -0.715730825283819, -0.713584868780794, -0.711432195745217, -0.709272826438866,
    -0.707106781186548, -0.704934080375905, -0.702754744457225, -0.700568793943248, -0.698376249408973, -0.696177131491463, -0.693971460889654, -0.691759258364158,
    -0.689540544737067, -0.687315340891759, -0.685083667772700, -0.682845546385248, -0.680600997795453, -0.678350043129861, -0.676092703575316, -0.673829000378756,
    -0.671558954847019, -0.669282588346636, -0.666999922303638, -0.664710978203345, -0.662415777590172, -0.660114342067420, -0.657806693297079, -0.655492852999616,
    -0.653172842953777, -0.650846684996381, -0.648514401022112, -0.646176012983317, -0.643831542889792, -0.641481012808584, -0.639124444863776, -0.636761861236284,
    -0.634393284163646, -0.632018735939809, -0.629638238914927, -0.627251815495144, -0.624859488142386, -0.622461279374150, -0.620057211763289, -0.617647307937804,
    -0.615231590580627, -0.612810082429410, -0.610382806276309, -0.607949784967774, -0.605511041404326, -0.603066598540348, -0.600616479383869, -0.598160706996342,
    -0.595699304492433, -0.593232295039800, -0.590759701858874, -0.588281548222646, -0.585797857456439, -0.583308652937698, -0.580813958095765, -0.578313796411656,
    -0.575808191417845, -0.573297166698043, -0.570780745886967, -0.568258952670131, -0.565731810783613, -0.563199344013834, -0.560661576197336, -0.558118531220556,
    -0.555570233019602, -0.553016705580028, -0.550457972936605, -0.547894059173100, -0.545324988422047, -0.542750784864516, -0.540171472729893, -0.537587076295646,
    -0.534997619887097, -0.532403127877198, -0.529803624686295, -0.527199134781901, -0.524589682678469, -0.521975292937155, -0.519355990165589, -0.516731799017650,
    -0.514102744193222, -0.511468850437970, -0.508830142543107, -0.506186645345155, -0.503538383725718, -0.500885382611241, -0.498227666972782, -0.495565261825773,
    -0.492898192229784, -0.490226483288291, -0.487550160148436, -0.484869248000791, -0.482183772079123, -0.479493757660153, -0.476799230063322, -0.474100214650551,
    -0.471396736825998, -0.468688822035828, -0.465976495767967, -0.463259783551860, -0.460538710958240, -0.457813303598878, -0.455083587126344, -0.452349587233771,
    -0.449611329654607, -0.446868840162374, -0.444122144570430, -0.441371268731717, -0.438616238538528, -0.435857079922256, -0.433093818853152, -0.430326481340083,
    -0.427555093430282, -0.424779681209109, -0.422000270799800, -0.419216888363224, -0.416429560097637, -0.413638312238435, -0.410843171057904, -0.408044162864979,
    -0.405241314004990, -0.402434650859419, -0.399624199845647, -0.396809987416711, -0.393992040061048, -0.391170384302254, -0.388345046698827, -0.385516053843919,
    -0.382683432365090, -0.379847208924051, -0.377007410216418, -0.374164062971458, -0.371317193951838, -0.368466829953372, -0.365612997804774, -0.362755724367397,
    -0.359895036534988, -0.357030961233430, -0.354163525420490, -0.351292756085567, -0.348418680249435, -0.345541324963989, -0.342660717311995, -0.339776884406827,
    -0.336889853392220, -0.333999651442010, -0.331106305759877, -0.328209843579092, -0.325310292162263, -0.322407678801070, -0.319502030816015, -0.316593375556166,
    -0.313681740398891, -0.310767152749612, -0.307849640041535, -0.304929229735402, -0.302005949319229, -0.299079826308041, -0.296150888243624, -0.293219162694259,
    -0.290284677254462, -0.287347459544729, -0.284407537211272, -0.281464937925758, -0.278519689385054, -0.275571819310958, -0.272621355449949, -0.269668325572916,
    -0.266712757474899, -0.263754678974831, -0.260794117915276, -0.257831102162159, -0.254865659604514, -0.251897818154217, -0.248927605745720, -0.245955050335795,
    -0.242980179903264, -0.240003022448741, -0.237023605994368, -0.234041958583544, -0.231058108280671, -0.228072083170886, -0.225083911359793, -0.222093620973203,
    -0.219101240156870, -0.216106797076219, -0.213110319916092, -0.210111836880470, -0.207111376192218, -0.204108966092817, -0.201104634842092, -0.198098410717953,
    -0.195090322016129, -0.192080397049893, -0.189068664149806, -0.186055151663447, -0.183039887955141, -0.180022901405700, -0.177004220412149, -0.173983873387464,
    -0.170961888760302, -0.167938294974731, -0.164913120489970, -0.161886393780112, -0.158858143333862, -0.155828397654265, -0.152797185258444, -0.149764534677322,
    -0.146730474455362, -0.143695033150295, -0.140658239332849, -0.137620121586487, -0.134580708507126, -0.131540028702883, -0.128498110793794, -0.125454983411546,
    -0.122410675199216, -0.119365214810992, -0.116318630911905, -0.113270952177565, -0.110222207293883, -0.107172424956809, -0.104121633872055, -0.101069862754828,
    -0.098017140329560, -0.094963495329639, -0.091908956497133, -0.088853552582524, -0.085797312344440, -0.082740264549376, -0.079682437971431, -0.076623861392032,
    -0.073564563599667, -0.070504573389614, -0.067443919563664, -0.064382630929857, -0.061320736302209, -0.058258264500436, -0.055195244349690, -0.052131704680284,
    -0.049067674327418, -0.046003182130915, -0.042938256934941, -0.039872927587740, -0.036807222941359, -0.033741171851378, -0.030674803176636, -0.027608145778966,
    -0.024541228522912, -0.021474080275469, -0.018406729905805, -0.015339206284988, -0.012271538285721, -0.009203754782060, -0.006135884649154, -0.003067956762966,
    -0.000000000000000,  0.003067956762966,  0.006135884649154,  0.009203754782060,  0.012271538285720,  0.015339206284988,  0.018406729905805,  0.021474080275469,
     0.024541228522912,  0.027608145778966,  0.030674803176636,  0.033741171851377,  0.036807222941359,  0.039872927587739,  0.042938256934941,  0.046003182130915,
     0.049067674327418,  0.052131704680283,  0.055195244349689,  0.058258264500435,  0.061320736302209,  0.064382630929857,  0.067443919563664,  0.070504573389614,
     0.073564563599667,  0.076623861392031,  0.079682437971430,  0.082740264549375,  0.085797312344440,  0.088853552582524,  0.091908956497132,  0.094963495329639,
     0.098017140329560,  0.101069862754828,  0.104121633872055,  0.107172424956808,  0.110222207293883,  0.113270952177565,  0.116318630911904,  0.119365214810991,
     0.122410675199216,  0.125454983411546,  0.128498110793793,  0.131540028702883,  0.134580708507126,  0.137620121586486,  0.140658239332849,  0.143695033150294,
     0.146730474455362,  0.149764534677321,  0.152797185258443,  0.155828397654265,  0.158858143333861,  0.161886393780112,  0.164913120489969,  0.167938294974731,
     0.170961888760301,  0.173983873387463,  0.177004220412149,  0.180022901405700,  0.183039887955141,  0.186055151663447,  0.189068664149806,  0.192080397049892,
     0.195090322016128,  0.198098410717953,  0.201104634842092,  0.204108966092817,  0.207111376192218,  0.210111836880470,  0.213110319916092,  0.216106797076219,
     0.219101240156870,  0.222093620973203,  0.225083911359793,  0.228072083170886,  0.231058108280671,  0.234041958583543,  0.237023605994367,  0.240003022448741,
     0.242980179903264,  0.245955050335795,  0.248927605745720,  0.251897818154217,  0.254865659604514,  0.257831102162159,  0.260794117915276,  0.263754678974831,
     0.266712757474898,  0.269668325572915,  0.272621355449949,  0.275571819310958,  0.278519689385053,  0.281464937925758,  0.284407537211272,  0.287347459544729,
     0.290284677254462,  0.293219162694259,  0.296150888243623,  0.299079826308040,  0.302005949319228,  0.304929229735402,  0.307849640041535,  0.310767152749612,
     0.313681740398891,  0.316593375556166,  0.319502030816015,  0.322407678801070,  0.325310292162263,  0.328209843579092,  0.331106305759876,  0.333999651442009,
     0.336889853392220,  0.339776884406827,  0.342660717311995,  0.345541324963989,  0.348418680249435,  0.351292756085567,  0.354163525420490,  0.357030961233430,
     0.359895036534988,  0.362755724367397,  0.365612997804774,  0.368466829953372,  0.371317193951837,  0.374164062971458,  0.377007410216418,  0.379847208924051,
     0.382683432365090,  0.385516053843919,  0.388345046698826,  0.391170384302253,  0.393992040061048,  0.396809987416710,  0.399624199845646,  0.402434650859418,
     0.405241314004990,  0.408044162864978,  0.410843171057904,  0.413638312238435,  0.416429560097637,  0.419216888363224,  0.422000270799799,  0.424779681209109,
     0.427555093430282,  0.430326481340082,  0.433093818853152,  0.435857079922256,  0.438616238538527,  0.441371268731717,  0.444122144570429,  0.446868840162374,
     0.449611329654607,  0.452349587233770,  0.455083587126344,  0.457813303598877,  0.460538710958240,  0.463259783551860,  0.465976495767966,  0.468688822035828,
     0.471396736825998,  0.474100214650550,  0.476799230063322,  0.479493757660153,  0.482183772079122,  0.484869248000791,  0.487550160148436,  0.490226483288291,
     0.492898192229784,  0.495565261825773,  0.498227666972781,  0.500885382611241,  0.503538383725718,  0.506186645345155,  0.508830142543107,  0.511468850437970,
     0.514102744193222,  0.516731799017650,  0.519355990165589,  0.521975292937154,  0.524589682678469,  0.527199134781901,  0.529803624686295,  0.532403127877198,
     0.534997619887097,  0.537587076295646,  0.540171472729892,  0.542750784864516,  0.545324988422046,  0.547894059173100,  0.550457972936605,  0.553016705580028,
     0.555570233019602,  0.558118531220556,  0.560661576197336,  0.563199344013834,  0.565731810783613,  0.568258952670131,  0.570780745886967,  0.573297166698042,
     0.575808191417845,  0.578313796411655,  0.580813958095765,  0.583308652937698,  0.585797857456439,  0.588281548222645,  0.590759701858874,  0.593232295039800,
     0.595699304492433,  0.598160706996342,  0.600616479383869,  0.603066598540348,  0.605511041404325,  0.607949784967774,  0.610382806276309,  0.612810082429410,
     0.615231590580627,  0.617647307937804,  0.620057211763289,  0.622461279374150,  0.624859488142386,  0.627251815495144,  0.629638238914927,  0.632018735939809,
     0.634393284163646,  0.636761861236284,  0.639124444863776,  0.641481012808583,  0.643831542889791,  0.646176012983316,  0.648514401022112,  0.650846684996381,
     0.653172842953777,  0.655492852999615,  0.657806693297079,  0.660114342067421,  0.662415777590171,  0.664710978203345,  0.666999922303638,  0.669282588346636,
     0.671558954847018,  0.673829000378756,  0.676092703575316,  0.678350043129861,  0.680600997795453,  0.682845546385248,  0.685083667772700,  0.687315340891759,
     0.689540544737067,  0.691759258364158,  0.693971460889654,  0.696177131491463,  0.698376249408972,  0.700568793943248,  0.702754744457225,  0.704934080375905,
     0.707106781186547,  0.709272826438866,  0.711432195745216,  0.713584868780794,  0.715730825283819,  0.717870045055731,  0.720002507961382,  0.722128193929215,
     0.724247082951467,  0.726359155084346,  0.728464390448225,  0.730562769227827,  0.732654271672413,  0.734738878095963,  0.736816568877370,  0.738887324460615,
     0.740951125354959,  0.743007952135122,  0.745057785441466,  0.747100605980180,  0.749136394523459,  0.751165131909686,  0.753186799043612,  0.755201376896537,
     0.757208846506484,  0.759209188978388,  0.761202385484262,  0.763188417263381,  0.765167265622459,  0.767138911935820,  0.769103337645579,  0.771060524261814,
     0.773010453362737,  0.774953106594874,  0.776888465673233,  0.778816512381476,  0.780737228572094,  0.782650596166576,  0.784556597155575,  0.786455213599086,
     0.788346427626606,  0.790230221437310,  0.792106577300212,  0.793975477554337,  0.795836904608883,  0.797690840943391,  0.799537269107905,  0.801376171723140,
     0.803207531480645,  0.805031331142963,  0.806847553543799,  0.808656181588175,  0.810457198252595,  0.812250586585204,  0.814036329705948,  0.815814410806734,
     0.817584813151584,  0.819347520076797,  0.821102514991105,  0.822849781375826,  0.824589302785025,  0.826321062845663,  0.828045045257755,  0.829761233794523,
     0.831469612302545,  0.833170164701913,  0.834862874986380,  0.836547727223512,  0.838224705554838,  0.839893794195999,  0.841554977436898,  0.843208239641845,
     0.844853565249707,  0.846490938774052,  0.848120344803297,  0.849741768000852,  0.851355193105265,  0.852960604930364,  0.854557988365401,  0.856147328375194,
     0.857728610000272,  0.859301818357008,  0.860866938637767,  0.862423956111041,  0.863972856121586,  0.865513624090569,  0.867046245515693,  0.868570705971341,
     0.870086991108711,  0.871595086655951,  0.873094978418290,  0.874586652278176,  0.876070094195407,  0.877545290207261,  0.879012226428633,  0.880470889052160,
     0.881921264348355,  0.883363338665732,  0.884797098430937,  0.886222530148881,  0.887639620402854,  0.889048355854664,  0.890448723244758,  0.891840709392343,
     0.893224301195515,  0.894599485631383,  0.895966249756185,  0.897324580705418,  0.898674465693954,  0.900015892016160,  0.901348847046022,  0.902673318237259,
     0.903989293123443,  0.905296759318119,  0.906595704514915,  0.907886116487666,  0.909167983090522,  0.910441292258067,  0.911706032005430,  0.912962190428398,
     0.914209755703530,  0.915448716088268,  0.916679059921043,  0.917900775621390,  0.919113851690058,  0.920318276709111,  0.921514039342042,  0.922701128333879,
     0.923879532511287,  0.925049240782677,  0.926210242138311,  0.927362525650401,  0.928506080473215,  0.929640895843181,  0.930766961078983,  0.931884265581668,
     0.932992798834739,  0.934092550404259,  0.935183509938948,  0.936265667170278,  0.937339011912575,  0.938403534063108,  0.939459223602190,  0.940506070593268,
     0.941544065183021,  0.942573197601447,  0.943593458161960,  0.944604837261480,  0.945607325380521,  0.946600913083284,  0.947585591017741,  0.948561349915730,
     0.949528180593037,  0.950486073949481,  0.951435020969008,  0.952375012719766,  0.953306040354194,  0.954228095109106,  0.955141168305771,  0.956045251349996,
     0.956940335732209,  0.957826413027533,  0.958703474895871,  0.959571513081985,  0.960430519415566,  0.961280485811321,  0.962121404269042,  0.962953266873684,
     0.963776065795440,  0.964589793289813,  0.965394441697689,  0.966190003445413,  0.966976471044852,  0.967753837093475,  0.968522094274417,  0.969281235356548,
     0.970031253194544,  0.970772140728950,  0.971503890986252,  0.972226497078936,  0.972939952205560,  0.973644249650812,  0.974339382785576,  0.975025345066994,
     0.975702130038528,  0.976369731330021,  0.977028142657754,  0.977677357824510,  0.978317370719628,  0.978948175319062,  0.979569765685441,  0.980182135968117,
     0.980785280403230,  0.981379193313755,  0.981963869109555,  0.982539302287441,  0.983105487431216,  0.983662419211730,  0.984210092386929,  0.984748501801904,
     0.985277642388941,  0.985797509167567,  0.986308097244599,  0.986809401814185,  0.987301418157858,  0.987784141644572,  0.988257567730749,  0.988721691960324,
     0.989176509964781,  0.989622017463201,  0.990058210262297,  0.990485084256457,  0.990902635427780,  0.991310859846115,  0.991709753669099,  0.992099313142192,
     0.992479534598710,  0.992850414459865,  0.993211949234795,  0.993564135520595,  0.993906970002356,  0.994240449453188,  0.994564570734255,  0.994879330794806,
     0.995184726672197,  0.995480755491927,  0.995767414467660,  0.996044700901252,  0.996312612182778,  0.996571145790555,  0.996820299291166,  0.997060070339483,
     0.997290456678690,  0.997511456140303,  0.997723066644192,  0.997925286198596,  0.998118112900149,  0.998301544933893,  0.998475580573295,  0.998640218180265,
     0.998795456205172,  0.998941293186857,  0.999077727752645,  0.999204758618364,  0.999322384588349,  0.999430604555462,  0.999529417501093,  0.999618822495179,
     0.999698818696204,  0.999769405351215,  0.999830581795823,  0.999882347454213,  0.999924701839145,  0.999957644551964,  0.999981175282601,  0.999995293809576
};


static OMX_ERRORTYPE linear2minimum_phase(t_float *p_min_phase_filter_coef,
                                          t_float *p_square_lin_phase_filter_coef,
                                          int      n,
                                          int      iter_max)
{
/*
function [y, ssp, iter] = minphase(h, iter_max, y)
  %% function [y, ssp, iter] = minphase(h)
  %%
  %% Function for extracting the minimum-phase factor from
  %% the linear-phase filter h.
  %% Input:
  %%     h = [h(0), h(1), ..., h(N)]   row vector
  %% where the h vector is the right half of a linear-phase FIR filter.
  %% It is presumed that any unit-circle zeros of h are of even
  %% multiplicity.
  %%
  %% Example 1:
  %%   f(z) = 2 + z^{11} + z^{-11}   -> minphase_f(z) = 1 + z^{-11}
  %%
  %%   b  = zeros(1,23); l=length(b)+1; b(1)=b(l-1)=1; b(l/2)=2;
  %%   [bm, ssp, it] = minphase(b((l/2):(l-1)));
  %%   bm_ref = zeros(1,12); bm_ref(1)=bm_ref(12)=1;
  %%   assert((norm(bm-bm_ref)<1e-8) && (abs(it-27)==0));
  %%
  %% Example 2:
  %%   Br(z) : random polynomial of degree 15
  %%   B(z) = Br(z) * Br(1/z) * z**15
  %%   Bm   = minphase_B(z)                (Bm and Br should be identical)
  %%
  %%   br = rand(1,16); b = conv(br,fliplr(br));
  %%   l = length(b)+1; bm = minphase(b((l/2):(l-1)));
  %%   [Bm,w] = freqz(bm,1,512); [Br,w] = freqz(br,1,512);
  %%   assert((norm(abs(Br)-abs(Bm))<1e-12) && (abs(roots(bm))<=1));
  %%
  %%
  %% Copyright (c) January 2002, by H. J. Orchard ad A. N. Willson Jr.

  if nargin < 3
    y = [1 zeros(1, length(h)-1)];  % initialize y
  end
  if nargin < 2
    iter_max = 10;
  end
  ssp = realmax;                    % a large number
  ss = ssp/2;                       % smaller large number
  iter = 0; d = 0;                  % init. iter. counter and correction vector
  while (ss < ssp) && (iter < iter_max)
    y = y + d'; ssp = ss;           % update y and move old norm(d) value
    iter = iter + 1;                % incr. the iteration count
    Ar = toeplitz([y(1), zeros(1,length(h)-1)], y);
    Al = fliplr(toeplitz([y(length(h)), zeros(1,length(h)-1)], fliplr(y)));
    A = Al + Ar;                    % Create the A matrix
    b = h' - Al*y';                 % and create the b vector
    d = A\b;                        % solve Ad = b for the correction vector d
    ss = norm(d);                   % get norm to see if we're still decreasing
  end

end
*/
    t_float *h, *y, *d, *a, *b;
    t_float ssp, ss, ratio, max_ratio, aa, bb;
    int     iter, i, j, k1, k2, k3, line, max_ratio_line;


    y = p_min_phase_filter_coef;
    h = p_square_lin_phase_filter_coef;
    a = (t_float *) my_malloc(n * n * sizeof(t_float));
    if(a == NULL)
    {
        return OMX_ErrorInsufficientResources;
    }
    b = (t_float *) my_malloc(n * sizeof(t_float));
    if(b == NULL)
    {
        my_free(a);
        return OMX_ErrorInsufficientResources;
    }
    d = b;

    // initialize minimum phase FIR with identity filter
    y[0] = 1.0;
    for(i = 1; i < n; i++)
    {
        y[i] = 0.0;
    }

    for(i = 0; i < n; i++)
    {
        d[i] = 0.0;
    }
    ss   = -1.0;
    iter = 0;
    do
    {
        iter++;
        ssp = ss;

        // y = y + d'
        for(i = 0; i < n; i++)
        {
            y[i] += d[i];
        }

        // Ar = toeplitz([y(1), zeros(1,length(h)-1)], y)
        // Al = fliplr(toeplitz([y(length(h)), zeros(1,length(h)-1)], fliplr(y)))
        // A = Al + Ar
        // b = h' - Al*y'
        k1 = 0;
        for(i = 0; i < n; i++)
        {
            b[i] = h[i];
            for(j = 0; j < n; j++)
            {
                if(i + j < n)
                {
                    a[k1] = y[i + j];       // Al(i,j)
                    b[i] -= a[k1] * y[j];
                }
                else
                {
                    a[k1] = 0.0;
                }
                if(j >= i)
                {
                    a[k1] += y[j - i];      // A(i,j) = Al(i,j) + Ar(i,j)
                }
                assert(k1 == i * n + j);
                k1++;
            }
        }

        // d = A\b;                        # solve Ad = b for the correction vector d
        max_ratio_line = 0;
        for(line = 0; line < n ; line++)
        {
            // search best line
            k1        = line * n;
            max_ratio = -1.0;
            for(i = line; i < n; i++)
            {
                k1   += line;
                k2    = k1;
                ratio = 0.0;
                for(j = line; j < n; j++)
                {
                    assert(k1 == i * n + j);
                    ratio += Fabs(a[k1++]);
                }
                if(ratio == 0.0)
                {
                    my_free(a);
                    my_free(b);
                    return OMX_ErrorBadParameter;
                }
                assert(k2 == i * n + line);
                ratio = Fabs(a[k2]) / ratio;
                if(ratio > max_ratio)
                {
                    max_ratio_line = i;
                    max_ratio      = ratio;
                }
            }
            if(max_ratio == 0.0)
            {
                my_free(a);
                my_free(b);
                return OMX_ErrorBadParameter;
            }

            // swap current line with best line if they are different
            if(max_ratio_line != line)
            {
                t_float swap;

                k1 = max_ratio_line * n + line;
                k2 = line           * n + line;
                for(j = line; j < n; j++)
                {
                    assert(k1 == max_ratio_line * n + j);
                    assert(k2 == line           * n + j);
                    swap    = a[k1];
                    a[k1++] = a[k2];
                    a[k2++] = swap;
                }
                swap              = b[max_ratio_line];
                b[max_ratio_line] = b[line];
                b[line]           = swap;
            }

            // elimination of column 'line' for line > 'line'
            aa = a[line * n + line];
            if(aa == 0.0)
            {
                my_free(a);
                my_free(b);
                return OMX_ErrorBadParameter;
            }
            k1 = line * n + line;
            for(i = line + 1; i < n; i++)
            {
                k1 += n;
                k2  = line * n + line + 1;
                k3  = k1;
                assert(k1 == i * n + line);
                ratio   = a[k1] / aa;
                a[k3++] = 0.0;
                for(j = line + 1; j < n; j++)
                {
                    assert(k2 == line * n + j);
                    assert(k3 == i    * n + j);
                    a[k3++] -= ratio * a[k2++];
                }
                b[i] -= ratio * b[line];
            }
        }

        // retro-propagation of found values from last to first line
        k1 = (n - 1) * n + (n - 1);
        for(line = n - 1; line >= 0; line--)
        {
            assert(k1 == line * n + line);
            if(a[k1] == 0.0)
            {
                my_free(a);
                my_free(b);
                return OMX_ErrorBadParameter;
            }
            bb = b[line] / a[k1];
            k2 = k1;
            for(i = line - 1; i >= 0; i--)
            {
                k2 -= n;
                assert(k2 == i * n + line);
                b[i] -= a[k2] * bb;
                a[k2] = 0.0;
            }
            d[line] = bb;
            k1 -= (n + 1);
        }

        // ss = norm(d);                   # get norm to see if we're still decreasing
        ss = 0.0;
        for(i = 0; i < n; i++)
        {
            ss += d[i] * d[i];
        }
    }
    while((iter < 3) || ((ss < ssp) && (iter < iter_max)));

    my_free(a);
    my_free(b);

    return OMX_ErrorNone;
}


OMX_ERRORTYPE TEQ_SHAI_compute_FIR(OMX_AUDIO_PHASERESPONSETYPE   ePhaseResponseTargetFir,
                                   OMX_AUDIO_CONFIG_FIR_RESPONSE *p_firConfig,
                                   OMX_U32                       nSamplingRate,
                                   t_FIR_filter_quantified       *p_FIR_filter_quantified,
                                   int                           FIR_size,
                                   int                           nb_bits_quantif,
                                   int                           instance)
{
    int     max_freq = ((int) nSamplingRate) / 2;
    int     *freq_table, *gain_table;
    t_float *gain_interpol, *b;
    int     i, j, n, shift, FIR_size_lp, p, ind_bb;
    t_float df, f, f1, f2, g1, g2;
    t_float theta, d_theta, coef_b, bb[2], b_tmp, max_mod2, b_min, b_max;
    t_float coef_quantif = pow2_float[nb_bits_quantif - 1] / max_float[nb_bits_quantif - 1];

    if(FIR_size == 0)
    {
        p_FIR_filter_quantified->gain_exp  = (OMX_S16) 1;
        p_FIR_filter_quantified->gain_mant = (OMX_S32) 0x40000000;

        return OMX_ErrorNone;
    }

    if(FIR_size > p_FIR_filter_quantified->nb_max_coefs)
    {
        return OMX_ErrorBadParameter;
    }

    // check response type
    if(   (ePhaseResponseTargetFir != OMX_AUDIO_LinearPhase)
       && (ePhaseResponseTargetFir != OMX_AUDIO_MinimumPhase))
    {
        return OMX_ErrorBadParameter;
    }

    n = (int) p_firConfig->nFrequencyPoints;
    if(n == 0)
    {
        // flat response
        p_FIR_filter_quantified->coef[0] = (OMX_S32) max_int_Q31[nb_bits_quantif - 1];
        for(i = 1; i < FIR_size; i++)
        {
            p_FIR_filter_quantified->coef[i] = (OMX_S32) 0;
        }
        p_FIR_filter_quantified->gain_exp  = (OMX_S16) 1;
        p_FIR_filter_quantified->gain_mant = (OMX_S32) 0x40000000;

        return OMX_ErrorNone;
    }

    // get freq_table & gain_table from p_firConfig
    freq_table = (int *) my_malloc((n + 2) * sizeof(int));
    if(freq_table == NULL)
    {
        return OMX_ErrorInsufficientResources;
    }
    gain_table = (int *) my_malloc((n + 2) * sizeof(int));
    if(gain_table == NULL)
    {
        my_free(freq_table);
        return OMX_ErrorInsufficientResources;
    }
    for(i = 0; i < n; i++)
    {
        freq_table[i] = (int) p_firConfig->nFrequencies[i];
        gain_table[i] = (int) p_firConfig->nGains[i];
    }

    // sort freq_table and gain_table in frequency order
    for(i = 0; i < n - 1; i++)
    {
        for(j = i + 1; j < n; j++)
        {
            if(freq_table[j] < freq_table[i])
            {
                int swap;

                swap          = freq_table[i];
                freq_table[i] = freq_table[j];
                freq_table[j] = swap;
                swap          = gain_table[i];
                gain_table[i] = gain_table[j];
                gain_table[j] = swap;
            }
        }
    }

    // check that all frequencies are in the range [0, max_freq] and are all different between each other
    for(i = 0; i < n; i++)
    {
        if(freq_table[i] > max_freq)    // freq_table[i] can't be < 0 because it comes from an OMX_U32
        {
            return OMX_ErrorBadParameter;
        }
    }
    for(i = 0; i < n - 1; i++)
    {
        if(freq_table[i] == freq_table[i + 1])
        {
            return OMX_ErrorBadParameter;
        }
    }

    if(freq_table[0] > 0)
    {
        // if frequency 0 not present, shift freq_table to insert frequency 0
        for(i = n; i > 0; i--)
        {
            freq_table[i] = freq_table[i - 1];
            gain_table[i] = gain_table[i - 1];
        }

        // insert frequency 0
        freq_table[0] = 0;
        gain_table[0] = gain_table[1];
        n++;
    }
    if(freq_table[n - 1] < max_freq)
    {
        // add frequency sampling_freq/2 if not present
        freq_table[n] = max_freq;
        gain_table[n] = gain_table[n - 1];
        n++;
    }

    // gain_table interpolation
    gain_interpol = (t_float *) my_malloc((COS_TABLE_SIZE / 2) * sizeof(t_float));
    if(gain_interpol == NULL)
    {
        my_free(freq_table);
        my_free(gain_table);
        return OMX_ErrorInsufficientResources;
    }
    f1 = (t_float) freq_table[0];
    f2 = (t_float) freq_table[1];
    g1 = Pow10(((t_float) gain_table[0]) / 2000.0);
    g2 = Pow10(((t_float) gain_table[1]) / 2000.0);
    df = ((t_float) max_freq) / ((t_float) (COS_TABLE_SIZE / 2));
    f  = 0.0;
    j  = 1;
    for(i = 0; i < (COS_TABLE_SIZE / 2); i++)
    {
        if(f > f2)
        {
            f1 = f2;
            g1 = g2;
            j++;
            f2 = (t_float) freq_table[j];
            g2 = Pow10(((t_float) gain_table[j]) / 2000.0);
        }
        gain_interpol[i] = g1 + (g2 - g1) / (f2 - f1) * (f - f1);
        f               += df;
    }
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 5
    fprintf(debug_TEQ_SHAI_file[instance], "gain_interpol :\n");
    f = 0.0;
    for(i = 0; i < (COS_TABLE_SIZE / 2); i++)
    {
        fprintf(debug_TEQ_SHAI_file[instance], "%8.2f Hz : %1.8f\n", f, gain_interpol[i]);
        f += df;
    }
    fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 5

    // if linear phase FIR, take the square root
    if(ePhaseResponseTargetFir == OMX_AUDIO_LinearPhase)
    {
        FIR_size_lp = FIR_size;
        if(FIR_size & 1)
        {
            p = FIR_size;
        }
        else
        {
            p = FIR_size - 1;
        }
    }
    else
    {
        for(i = 0; i < (COS_TABLE_SIZE / 2); i++)
        {
            gain_interpol[i] *= gain_interpol[i];
        }
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 5
        fprintf(debug_TEQ_SHAI_file[instance], "gain_interpol^2 for minimum phase :\n");
        f = 0.0;
        for(i = 0; i < (COS_TABLE_SIZE / 2); i++)
        {
            fprintf(debug_TEQ_SHAI_file[instance], "%8.2f Hz : %1.8f\n", f, gain_interpol[i]);
            f += df;
        }
        fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 5
        p = FIR_size_lp = 2 * FIR_size - 1;
    }

    // idft of real symmetric input and hamming ponderation of first p + 1 points
    b = (t_float *) my_malloc(FIR_size_lp * sizeof(t_float));
    if(b == NULL)
    {
        my_free(freq_table);
        my_free(gain_table);
        my_free(gain_interpol);
        return OMX_ErrorInsufficientResources;
    }
    if(p < FIR_size_lp)
    {
        // (ePhaseResponseTargetFir == OMX_AUDIO_LinearPhase) && FIR_size is even => last coef is 0
        // (linear phase FIR size is always odd => set last coef to 0 to obtain even size)
        b[p] = 0.0;
    }
    p      /= 2;
    d_theta = PI / ((t_float) p);
    theta   = 0.0;
    ind_bb  = 0;
    bb[0]   = (gain_interpol[0] + gain_interpol[(COS_TABLE_SIZE / 2) - 1]) / 2.0;
    bb[1]   = (gain_interpol[0] - gain_interpol[(COS_TABLE_SIZE / 2) - 1]) / 2.0;
    b_tmp   = bb[ind_bb];
    for(j = 1; j < (COS_TABLE_SIZE / 2); j++)
    {
        b_tmp += gain_interpol[j];
    }
    b[p] = b_tmp / ((t_float) (COS_TABLE_SIZE / 2));    // Hamming weighting = 1.0 for this coef
    for(i = 1; i <= p; i++)
    {
        int k = 0;

        ind_bb = (ind_bb + 1) % 2;
        b_tmp  = bb[ind_bb];
        for(j = 1; j < (COS_TABLE_SIZE / 2); j++)
        {
            k      = (k + i) % COS_TABLE_SIZE;
            b_tmp += cos_table[k] * gain_interpol[j];
        }
        theta   += d_theta;
        b[p + i] = b_tmp / ((t_float) (COS_TABLE_SIZE / 2)) * (0.54 + 0.46 * Cos(theta));
        b[p - i] = b[p + i];                            // symetrization
    }
    my_free(gain_interpol);
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
    fprintf(debug_TEQ_SHAI_file[instance], "FIR linear phase coef before normalization :\n");
    fprintf(debug_TEQ_SHAI_file[instance], "b%d = %+1.8f\n", p, b[p]);
    for(i = 1; i < p + 1; i++)
    {
        fprintf(debug_TEQ_SHAI_file[instance], "b%d = b%d = %+1.8f\n", p - i, p + i, b[p - i]);
    }
    fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3

    if(ePhaseResponseTargetFir == OMX_AUDIO_MinimumPhase)
    {
        OMX_ERRORTYPE ret;
        t_float       *b_square_lin_phase = b;
        t_float       *b_min_phase        = (t_float *) my_malloc(FIR_size * sizeof(t_float));

        if(b_min_phase == NULL)
        {
            my_free(freq_table);
            my_free(gain_table);
            my_free(b_square_lin_phase);
            return OMX_ErrorInsufficientResources;
        }

        ret = linear2minimum_phase(b_min_phase,
                                   b_square_lin_phase + FIR_size - 1,
                                   FIR_size,
                                   10);
        my_free(b_square_lin_phase);
        b = b_min_phase;
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
        fprintf(debug_TEQ_SHAI_file[instance], "FIR minimum phase coef before normalization :\n");
        for(i = 0; i < FIR_size; i++)
        {
            fprintf(debug_TEQ_SHAI_file[instance], "b%d = %+1.8f\n", i, b[i]);
        }
        fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3

        if(ret != OMX_ErrorNone)
        {
            my_free(freq_table);
            my_free(gain_table);
            my_free(b_min_phase);
            return ret;
        }
    }

    // compute max(module) for further quantization
    max_mod2 = 0.0;
    for(i = 0; i < (COS_TABLE_SIZE / 2); i++)
    {
        t_float mod_re, mod_im, mod2;
        int     k_cos, k_sin;

        k_cos  = 0;
        mod_re = 0.0;
        mod_im = 0.0;
        for(j = 0; j < FIR_size; j++)
        {
            k_sin   = (k_cos + 3 * COS_TABLE_SIZE / 4) % COS_TABLE_SIZE;
            mod_re += cos_table[k_cos] * b[j];
            mod_im += cos_table[k_sin] * b[j];
            k_cos   = (k_cos + i) % COS_TABLE_SIZE;
        }
        mod2     = mod_re * mod_re + mod_im * mod_im;
        max_mod2 = max(max_mod2, mod2);
    }
    coef_b = Sqrt(max_mod2) * coef_quantif;

    b_min = 0.0;
    b_max = 0.0;
    for(i = 0; i < FIR_size; i++)
    {
        b_min = min(b_min, b[i]);
        b_max = max(b_max, b[i]);
    }
    coef_b = max(coef_b, max(b_max * coef_quantif, -b_min));
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 2
    fprintf(debug_TEQ_SHAI_file[instance], "FIR gain before quantization :\n");
    fprintf(debug_TEQ_SHAI_file[instance], "gain = %1.8f\n", coef_b);
    fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 2

    // quantization and save result in p_FIR_filter_quantified structure
    for(i = 0; i < FIR_size; i++)
    {
        p_FIR_filter_quantified->coef[i] = float2Q31(b[i] / coef_b, nb_bits_quantif);
    }
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 2
    fprintf(debug_TEQ_SHAI_file[instance], "FIR coef after normalization and %d bits quantization :\n", nb_bits_quantif);
    for(i = 0; i < FIR_size; i++)
    {
        fprintf(debug_TEQ_SHAI_file[instance], "coef[%d] = 0x%08X\n", i, (int) p_FIR_filter_quantified->coef[i]);
    }
    fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 2
    my_free(b);

    //shift   = (int) Ceil(Log2(coef_b * coef_quantif));
    //coef_b /= Pow2(shift);
    shift = 0;
    if(coef_b != 0.0)
    {
        b_tmp = coef_b * coef_quantif;
        while(b_tmp > 1.0)
        {
            b_tmp  *= 0.5;
            coef_b *= 0.5;
            shift++;
        }
        while(b_tmp <= 0.5)
        {
            b_tmp  *= 2.0;
            coef_b *= 2.0;
            shift--;
        }
    }
    p_FIR_filter_quantified->gain_exp  = (OMX_S16) shift;
    p_FIR_filter_quantified->gain_mant = float2Q31(coef_b, nb_bits_quantif);
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 2
    fprintf(debug_TEQ_SHAI_file[instance], "FIR gain after normalization and %d bits quantization :\n", nb_bits_quantif);
    fprintf(debug_TEQ_SHAI_file[instance], "gain_exp  = %d\n",     (int) p_FIR_filter_quantified->gain_exp);
    fprintf(debug_TEQ_SHAI_file[instance], "gain_mant = 0x%08X\n", (int) p_FIR_filter_quantified->gain_mant);
    fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
    fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 2

#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
    {
        t_float coef = ((t_float) p_FIR_filter_quantified->gain_mant) * Pow2(p_FIR_filter_quantified->gain_exp - 62);
        int     i;

        fprintf(debug_TEQ_SHAI_file[instance], "Equivalent floating point FIR after %d bits quantization :\n", nb_bits_quantif);
        for(i = 0; i < FIR_size; i++)
        {
            fprintf(debug_TEQ_SHAI_file[instance], "%+12.9f ", ((t_float) p_FIR_filter_quantified->coef[i]) * coef);
            if((i % 8) == 7)
            {
                fprintf(debug_TEQ_SHAI_file[instance], "\n");
            }
        }
        if(i % 8)
        {
            fprintf(debug_TEQ_SHAI_file[instance], "\n");
        }
        fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
        fflush(debug_TEQ_SHAI_file[instance]);
    }
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4

#ifdef MATLAB_TEQ_SHAI_CONFIG
    {
        int i;

        fprintf(matlab_TEQ_SHAI_file[instance], "%% matlab response curve of order %d ", FIR_size);
        if(ePhaseResponseTargetFir == OMX_AUDIO_LinearPhase)
        {
            fprintf(matlab_TEQ_SHAI_file[instance], "linear phase ");
        }
        if(ePhaseResponseTargetFir == OMX_AUDIO_MinimumPhase)
        {
            fprintf(matlab_TEQ_SHAI_file[instance], "minimum phase ");
        }
        fprintf(matlab_TEQ_SHAI_file[instance], "FIR (%d bits quantization) :\n", nb_bits_quantif);
        fprintf(matlab_TEQ_SHAI_file[instance], "SamplingRate  = %d;\n", (int) nSamplingRate);
        fprintf(matlab_TEQ_SHAI_file[instance], "freq_table    = [");
        for(i = 0; i < n - 1; i++)
        {
            fprintf(matlab_TEQ_SHAI_file[instance], "%d ", freq_table[i]);
        }
        fprintf(matlab_TEQ_SHAI_file[instance], "%d];\n", freq_table[n - 1]);
        fprintf(matlab_TEQ_SHAI_file[instance], "gain_table_mB = [");
        for(i = 0; i < n - 1; i++)
        {
            fprintf(matlab_TEQ_SHAI_file[instance], "%d ", gain_table[i]);
        }
        fprintf(matlab_TEQ_SHAI_file[instance], "%d];\n", gain_table[n - 1]);
        fprintf(matlab_TEQ_SHAI_file[instance], "FIR           = [");
        for(i = 0; i < FIR_size - 1; i++)
        {
            fprintf(matlab_TEQ_SHAI_file[instance], "%d ", (int) p_FIR_filter_quantified->coef[i]);
        }
        fprintf(matlab_TEQ_SHAI_file[instance], "%d];\n", (int) p_FIR_filter_quantified->coef[FIR_size - 1]);
        fprintf(matlab_TEQ_SHAI_file[instance], "gain_mant     = %d;\n", (int) p_FIR_filter_quantified->gain_mant);
        fprintf(matlab_TEQ_SHAI_file[instance], "gain_exp      = %d;\n", (int) p_FIR_filter_quantified->gain_exp);
        fprintf(matlab_TEQ_SHAI_file[instance], "FIR           = FIR / 2^31 * gain_mant * 2^(gain_exp - 31);\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "N             = 1024;\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "min_dB        = -40.0;\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "H_FIR         = freqz(FIR, [1], N);\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "freq_axis     = [0 : N - 1] / N * SamplingRate / 2;\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "gain_table    = power(10.0, gain_table_mB / 2000.0);\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "clf(gcf);\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "subplot(1, 2, 1);\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "hold on;\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "title('quantified FIR (linear)');\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "plot(freq_table, gain_table, '--g');\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "plot(freq_axis,  abs(H_FIR), '-r');\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "subplot(1, 2, 2);\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "hold on;\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "title('quantified FIR (dB)');\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "plot(freq_table, max(min_dB, gain_table_mB / 100.0),    '--g');\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "plot(freq_axis,  max(min_dB, 20.0 * log10(abs(H_FIR))), '-r');\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "%%--------------------------------------------------\n");
        fflush(matlab_TEQ_SHAI_file[instance]);
    }
#endif // MATLAB_TEQ_SHAI_CONFIG

    my_free(freq_table);
    my_free(gain_table);
    my_check_free

    return OMX_ErrorNone;
}


OMX_ERRORTYPE TEQ_SHAI_compute_biquad(OMX_AUDIO_CONFIG_IIR_EQUALIZER *iirConfig,
                                      OMX_U32                        nSamplingRate,
                                      t_IIR_filter_float             *p_IIR_filter,
                                      int                            instance)
{
/*******************************************************************************

    On http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt :
    ========================================================


            Cookbook formulae for audio EQ biquad filter coefficients
    ----------------------------------------------------------------------------
            by Robert Bristow-Johnson  <rbj@audioimagination.com>


    All filter transfer functions were derived from analog prototypes (that
    are shown below for each EQ filter type) and had been digitized using the
    Bilinear Transform.  BLT frequency warping has been taken into account for
    both significant frequency relocation (this is the normal "prewarping" that
    is necessary when using the BLT) and for bandwidth readjustment (since the
    bandwidth is compressed when mapped from analog to digital using the BLT).

    First, given a biquad transfer function defined as:

                b0 + b1*z^-1 + b2*z^-2
        H(z) = ------------------------                                  (Eq 1)
                a0 + a1*z^-1 + a2*z^-2

    This shows 6 coefficients instead of 5 so, depending on your architechture,
    you will likely normalize a0 to be 1 and perhaps also b0 to 1 (and collect
    that into an overall gain coefficient).  Then your transfer function would
    look like:

                (b0/a0) + (b1/a0)*z^-1 + (b2/a0)*z^-2
        H(z) = ---------------------------------------                   (Eq 2)
                1 + (a1/a0)*z^-1 + (a2/a0)*z^-2

    or

                          1 + (b1/b0)*z^-1 + (b2/b0)*z^-2
        H(z) = (b0/a0) * ---------------------------------               (Eq 3)
                          1 + (a1/a0)*z^-1 + (a2/a0)*z^-2


    The most straight forward implementation would be the "Direct Form 1"
    (Eq 2):

        y[n] = (b0/a0)*x[n] + (b1/a0)*x[n-1] + (b2/a0)*x[n-2]
                            - (a1/a0)*y[n-1] - (a2/a0)*y[n-2]            (Eq 4)

    This is probably both the best and the easiest method to implement in the
    56K and other fixed-point or floating-point architechtures with a double
    wide accumulator.



    Begin with these user defined parameters:

        Fs (the sampling frequency)

        f0 ("wherever it's happenin', man."  Center Frequency or
            Corner Frequency, or shelf midpoint frequency, depending
            on which filter type.  The "significant frequency".)

        dBgain (used only for peaking and shelving filters)

        Q (the EE kind of definition, except for peakingEQ in which A*Q is
            the classic EE Q.  That adjustment in definition was made so that
            a boost of N dB followed by a cut of N dB for identical Q and
            f0/Fs results in a precisely flat unity gain filter or "wire".)

        _or_ BW, the bandwidth in octaves (between -3 dB frequencies for BPF
            and notch or between midpoint (dBgain/2) gain frequencies for
            peaking EQ)

        _or_ S, a "shelf slope" parameter (for shelving EQ only).  When S = 1,
            the shelf slope is as steep as it can be and remain monotonically
            increasing or decreasing gain with frequency.  The shelf slope, in
            dB/octave, remains proportional to S for all other values for a
            fixed f0/Fs and dBgain.



    Then compute a few intermediate variables:

        A  = sqrt( 10^(dBgain/20) )
           =       10^(dBgain/40)     (for peaking and shelving EQ filters only)

        w0 = 2*pi*f0/Fs

        cos(w0)
        sin(w0)

        alpha = sin(w0)/(2*Q)                                       (case: Q)
              = sin(w0)*sinh( ln(2)/2 * BW * w0/sin(w0) )           (case: BW)
              = sin(w0)/2 * sqrt( (A + 1/A)*(1/S - 1) + 2 )         (case: S)

            FYI: The relationship between bandwidth and Q is
                 1/Q = 2*sinh(ln(2)/2*BW*w0/sin(w0))     (digital filter w BLT)
            or   1/Q = 2*sinh(ln(2)/2*BW)             (analog filter prototype)

            The relationship between shelf slope and Q is
                 1/Q = sqrt((A + 1/A)*(1/S - 1) + 2)

        2*sqrt(A)*alpha  =  sin(w0) * sqrt( (A^2 + 1)*(1/S - 1) + 2*A )
            is a handy intermediate variable for shelving EQ filters.


    Finally, compute the coefficients for whichever filter type you want:
    (The analog prototypes, H(s), are shown for each filter
            type for normalized frequency.)


    LPF:        H(s) = 1 / (s^2 + s/Q + 1)

                b0 =  (1 - cos(w0))/2
                b1 =   1 - cos(w0)
                b2 =  (1 - cos(w0))/2
                a0 =   1 + alpha
                a1 =  -2*cos(w0)
                a2 =   1 - alpha



    HPF:        H(s) = s^2 / (s^2 + s/Q + 1)

                b0 =  (1 + cos(w0))/2
                b1 = -(1 + cos(w0))
                b2 =  (1 + cos(w0))/2
                a0 =   1 + alpha
                a1 =  -2*cos(w0)
                a2 =   1 - alpha



    BPF:        H(s) = s / (s^2 + s/Q + 1)  (constant skirt gain, peak gain = Q)

                b0 =   sin(w0)/2  =   Q*alpha
                b1 =   0
                b2 =  -sin(w0)/2  =  -Q*alpha
                a0 =   1 + alpha
                a1 =  -2*cos(w0)
                a2 =   1 - alpha


    BPF:        H(s) = (s/Q) / (s^2 + s/Q + 1)      (constant 0 dB peak gain)

                b0 =   alpha
                b1 =   0
                b2 =  -alpha
                a0 =   1 + alpha
                a1 =  -2*cos(w0)
                a2 =   1 - alpha



    notch:      H(s) = (s^2 + 1) / (s^2 + s/Q + 1)

                b0 =   1
                b1 =  -2*cos(w0)
                b2 =   1
                a0 =   1 + alpha
                a1 =  -2*cos(w0)
                a2 =   1 - alpha



    APF:        H(s) = (s^2 - s/Q + 1) / (s^2 + s/Q + 1)

                b0 =   1 - alpha
                b1 =  -2*cos(w0)
                b2 =   1 + alpha
                a0 =   1 + alpha
                a1 =  -2*cos(w0)
                a2 =   1 - alpha



    peakingEQ:  H(s) = (s^2 + s*(A/Q) + 1) / (s^2 + s/(A*Q) + 1)

                b0 =   1 + alpha*A
                b1 =  -2*cos(w0)
                b2 =   1 - alpha*A
                a0 =   1 + alpha/A
                a1 =  -2*cos(w0)
                a2 =   1 - alpha/A



    lowShelf: H(s) = A * (s^2 + (sqrt(A)/Q)*s + A)/(A*s^2 + (sqrt(A)/Q)*s + 1)

                b0 =    A*( (A+1) - (A-1)*cos(w0) + 2*sqrt(A)*alpha )
                b1 =  2*A*( (A-1) - (A+1)*cos(w0)                   )
                b2 =    A*( (A+1) - (A-1)*cos(w0) - 2*sqrt(A)*alpha )
                a0 =        (A+1) + (A-1)*cos(w0) + 2*sqrt(A)*alpha
                a1 =   -2*( (A-1) + (A+1)*cos(w0)                   )
                a2 =        (A+1) + (A-1)*cos(w0) - 2*sqrt(A)*alpha



    highShelf: H(s) = A * (A*s^2 + (sqrt(A)/Q)*s + 1)/(s^2 + (sqrt(A)/Q)*s + A)

                b0 =    A*( (A+1) + (A-1)*cos(w0) + 2*sqrt(A)*alpha )
                b1 = -2*A*( (A-1) + (A+1)*cos(w0)                   )
                b2 =    A*( (A+1) + (A-1)*cos(w0) - 2*sqrt(A)*alpha )
                a0 =        (A+1) - (A-1)*cos(w0) + 2*sqrt(A)*alpha
                a1 =    2*( (A-1) - (A+1)*cos(w0)                   )
                a2 =        (A+1) - (A-1)*cos(w0) - 2*sqrt(A)*alpha





    FYI:   The bilinear transform (with compensation for frequency warping)
    substitutes:

                                    1         1 - z^-1
        (normalized)   s  <--  ----------- * ----------
                                tan(w0/2)     1 + z^-1

    and makes use of these trig identities:

                        sin(w0)                               1 - cos(w0)
        tan(w0/2) = -------------           (tan(w0/2))^2 = -------------
                     1 + cos(w0)                             1 + cos(w0)


    resulting in these substitutions:


                    1 + cos(w0)     1 + 2*z^-1 + z^-2
        1    <--  ------------- * -------------------
                    1 + cos(w0)     1 + 2*z^-1 + z^-2


                    1 + cos(w0)     1 - z^-1
        s    <--  ------------- * ----------
                      sin(w0)       1 + z^-1

                                        1 + cos(w0)     1         -  z^-2
                                    =  ------------- * -------------------
                                          sin(w0)       1 + 2*z^-1 + z^-2


                    1 + cos(w0)     1 - 2*z^-1 + z^-2
        s^2  <--  ------------- * -------------------
                    1 - cos(w0)     1 + 2*z^-1 + z^-2


    The factor:

                        1 + cos(w0)
                    -------------------
                     1 + 2*z^-1 + z^-2

    is common to all terms in both numerator and denominator, can be factored
    out, and thus be left out in the substitutions above resulting in:


                    1 + 2*z^-1 + z^-2
        1    <--  -------------------
                       1 + cos(w0)


                    1         -  z^-2
        s    <--  -------------------
                       sin(w0)


                    1 - 2*z^-1 + z^-2
        s^2  <--  -------------------
                      1 - cos(w0)


    In addition, all terms, numerator and denominator, can be multiplied by a
    common (sin(w0))^2 factor, finally resulting in these substitutions:


        1         <--   (1 + 2*z^-1 + z^-2) * (1 - cos(w0))

        s         <--   (1         -  z^-2) * sin(w0)

        s^2       <--   (1 - 2*z^-1 + z^-2) * (1 + cos(w0))

        1 + s^2   <--   2 * (1 - 2*cos(w0)*z^-1 + z^-2)


    The biquad coefficient formulae above come out after a little
    simplification.

*******************************************************************************/

    t_float             FilterGain                  = (t_float) iirConfig->nFilterGain;
    t_float             FilterBandwidth             = (t_float) iirConfig->nFilterBandwidth;
    t_float             FilterCenterCutoffFrequency = (t_float) iirConfig->nFilterCenterCutoffFrequency;
    t_float             SamplingRate                = (t_float) nSamplingRate;
    t_float             omega, sn, cs, rbandwidth, BW, A, alpha, t0, t1, t2, t3;
    t_float             b0, b1, b2, a0, a1, a2;
    t_biquad_cell_float *p_biquad_cell;


#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
    fprintf(debug_TEQ_SHAI_file[instance], "TEQ_SHAI_compute_biquad :\n");
    fprintf(debug_TEQ_SHAI_file[instance], "FilterGain                  = %1.0f mB\n", FilterGain);
    fprintf(debug_TEQ_SHAI_file[instance], "FilterCenterCutoffFrequency = %1.0f Hz\n", FilterCenterCutoffFrequency);
    fprintf(debug_TEQ_SHAI_file[instance], "FilterBandwidth             = %1.0f Hz\n", FilterBandwidth);
    fprintf(debug_TEQ_SHAI_file[instance], "SamplingRate                = %1.0f Hz\n", SamplingRate);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3

    /* do not accept to create biquads with a too low or too high
       central frequency; this limit corresponds :
          - to 20Hz at     Fs= 8000Hz
          - to 120Hz at    Fs=48000Hz
          - to 110.25Hz at Fs=44100Hz
    */
    omega = FilterCenterCutoffFrequency / SamplingRate;
    if((omega < 0.0025) || (omega > 0.4975))
    //if((omega < 0.0005) || (omega > 0.4995))
    {
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
        fprintf(debug_TEQ_SHAI_file[instance], "WRONG FilterCenterCutoffFrequency / SamplingRate = %+1.8f !!!\n", omega);
        fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
        return OMX_ErrorBadParameter;
    }

    /* do not accept to create biquads with improper values */
    rbandwidth = FilterBandwidth / FilterCenterCutoffFrequency;
    if(rbandwidth < 0.00002)
    {
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
        fprintf(debug_TEQ_SHAI_file[instance], "WRONG FilterBandwidth / FilterCenterCutoffFrequency = %+1.8f !!!\n", rbandwidth);
        fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
        return OMX_ErrorBadParameter;
    }

    omega *= 2.0 * PI;
    sn     = Sin(omega);
    cs     = Cos(omega);

#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
    fprintf(debug_TEQ_SHAI_file[instance], "omega                       = %+1.8f\n", omega);
    fprintf(debug_TEQ_SHAI_file[instance], "sin(omega)                  = %+1.8f\n", sn);
    fprintf(debug_TEQ_SHAI_file[instance], "cos(omega)                  = %+1.8f\n", cs);
    fprintf(debug_TEQ_SHAI_file[instance], "rbandwidth                  = %+1.8f\n", rbandwidth);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3

    /*
       BiQuad requires bw to be expressed in octave rather than in Hz.
       The following reasoning provides the conversion:

          rbandwidth = (w0p - w0m)/w0;
      w0p = a w0;  w0m = 1/a w0;  with a>1 so that w0m < w0p
      bw = w0p/w0m = a**2; (actually converted in octave)

    Given those relationships, lets find "a" given "bandwidth":

      rbandwidth = (a - 1/a)  => a**2 - rbandwidth * a - 1 = 0
      delta**2 = rbandwidth**2 + 4
      a = 0.5*(rbandwidth + sqrt(rbandwidth**2 + 4))

        The other solution is negative and therefore not suitable;
    once b is found, bw can be evaluated as follow:

      bw_octave = log2(a**2) = 2 * log2(a);
    */
    BW    = 2.0 * Log2(0.5 * (rbandwidth + Sqrt(rbandwidth * rbandwidth + 4.0)));
    alpha = sn * Sinh(LOG_2 / 2.0 * BW * omega / sn);
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
    fprintf(debug_TEQ_SHAI_file[instance], "BW                          = %+1.8f octave\n", BW);
    fprintf(debug_TEQ_SHAI_file[instance], "alpha                       = %+1.8f\n", alpha);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3

    A = t0 = t1 = t2 = 0.0; // to remove warnings
    switch(iirConfig->eFilterType)
    {
        case OMX_AUDIO_Lowpass:
        case OMX_AUDIO_Highpass:
            A     = Pow10(FilterGain / 2000.0);
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            fprintf(debug_TEQ_SHAI_file[instance], "A                           = %+1.8f\n", A);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            break;

        case OMX_AUDIO_Peaking:
            A     = Pow10(FilterGain / 4000.0);
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            fprintf(debug_TEQ_SHAI_file[instance], "A                           = %+1.8f\n", A);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            break;

        case OMX_AUDIO_Lowshelf:
        case OMX_AUDIO_Highshelf:
            A     = Pow10(FilterGain / 4000.0);
            t0    = A + 1.0;
            t1    = A - 1.0;
            t2    = 2.0 * Sqrt(A) * alpha;
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            fprintf(debug_TEQ_SHAI_file[instance], "A                           = %+1.8f\n", A);
            fprintf(debug_TEQ_SHAI_file[instance], "alpha                       = %+1.8f\n", alpha);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            break;

        default:
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            return OMX_ErrorBadParameter;
    }

    switch(iirConfig->eFilterType)
    {
        case OMX_AUDIO_Lowpass:
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            fprintf(debug_TEQ_SHAI_file[instance], "FilterLowpass :\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            /*
            b0 = (1 - cs) / 2;
            b1 = 1 - cs;
            b2 = (1 - cs) / 2;
            a0 = 1 + alpha;
            a1 = -2 * cs;
            a2 = 1 - alpha;
            */
            b1 = A * (1.0 - cs);    // add FilterGain
            b0 = b1 / 2.0;
            b2 = b0;
            a0 = 1.0 + alpha;
            a1 = -2.0 * cs;
            a2 = 1.0 - alpha;
            break;

        case OMX_AUDIO_Highpass:
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            fprintf(debug_TEQ_SHAI_file[instance], "FilterHighpass :\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            /*
            b0 = (1 + cs) / 2;
            b1 = -(1 + cs);
            b2 = (1 + cs) / 2;
            a0 = 1 + alpha;
            a1 = -2 * cs;
            a2 = 1 - alpha;
            */
            b1 = A * (1.0 + cs);    // add FilterGain
            b0 = b1 / 2.0;
            b2 = b0;
            b1 = -b1;
            a0 = 1.0 + alpha;
            a1 = -2.0 * cs;
            a2 = 1.0 - alpha;
            break;

        case OMX_AUDIO_Peaking:
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            fprintf(debug_TEQ_SHAI_file[instance], "FilterPeaking :\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            /*
            b0 = 1 + (alpha * A);
            b1 = -2 * cs;
            b2 = 1 - (alpha * A);
            a0 = 1 + (alpha / A);
            a1 = -2 * cs;
            a2 = 1 - (alpha / A);
            */
            a1 = alpha * A;
            b0 = 1.0 + a1;
            b1 = -2.0 * cs;
            b2 = 1.0 - a1;
            a1 = alpha / A;
            a0 = 1.0 + a1;
            a2 = 1.0 - a1;
            a1 = b1;
            break;

        case OMX_AUDIO_Lowshelf:
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            fprintf(debug_TEQ_SHAI_file[instance], "FilterLowshelf :\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            /*
            b0 =      A * ((A + 1) - (A - 1) * cs + 2 * sqrt(A) * alpha)
            b1 =  2 * A * ((A - 1) - (A + 1) * cs)
            b2 =      A * ((A + 1) - (A - 1) * cs - 2 * sqrt(A) * alpha)
            a0 =           (A + 1) + (A - 1) * cs + 2 * sqrt(A) * alpha
            a1 = -2     * ((A - 1) + (A + 1) * cs)
            a2 =           (A + 1) + (A - 1) * cs - 2 * sqrt(A) * alpha
            */
            t3 = t0 - t1 * cs;
            b0 = A * (t3 + t2);
            b1 = 2.0 * A * (t1 - t0 * cs);
            b2 = A * (t3 - t2);
            t3 = t0 + t1 * cs;
            a0 = t3 + t2;
            a1 = -2.0 * (t1 + t0 * cs);
            a2 = t3 - t2;
            break;

        case OMX_AUDIO_Highshelf:
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            fprintf(debug_TEQ_SHAI_file[instance], "FilterHighshelf :\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            /*
            b0 =      A * ((A + 1) + (A - 1) * cs + 2 * sqrt(A) * alpha)
            b1 = -2 * A * ((A - 1) + (A + 1) * cs)
            b2 =      A * ((A + 1) + (A - 1) * cs - 2 * sqrt(A) * alpha)
            a0 =           (A + 1) - (A - 1) * cs + 2 * sqrt(A) * alpha
            a1 =  2     * ((A - 1) - (A + 1) * cs)
            a2 =           (A + 1) - (A - 1) * cs - 2 * sqrt(A) * alpha
            */
            t3 = t0 + t1 * cs;
            b0 = A * (t3 + t2);
            b1 = -2.0 * A * (t1 + t0 * cs);
            b2 = A * (t3 - t2);
            t3 = t0 - t1 * cs;
            a0 = t3 + t2;
            a1 = 2.0 * (t1 - t0 * cs);
            a2 = t3 - t2;
            break;

        default:
            return OMX_ErrorBadParameter;
    }

    p_biquad_cell = (t_biquad_cell_float *) my_malloc(sizeof(t_biquad_cell_float));
    if(p_biquad_cell == NULL)
    {
        return OMX_ErrorInsufficientResources;
    }
    p_biquad_cell->p_complex_zeros[0] = NULL;
    p_biquad_cell->p_complex_zeros[1] = NULL;
    p_biquad_cell->p_complex_poles[0] = NULL;
    p_biquad_cell->p_complex_poles[1] = NULL;
    p_biquad_cell->p_real_zeros   [0] = NULL;
    p_biquad_cell->p_real_zeros   [1] = NULL;
    p_biquad_cell->p_real_poles   [0] = NULL;
    p_biquad_cell->p_real_poles   [1] = NULL;
    p_biquad_cell->num.q0             = b0;
    p_biquad_cell->num.q1             = b1;
    p_biquad_cell->num.q2             = b2;
    p_biquad_cell->den.q0             = a0;
    p_biquad_cell->den.q1             = a1;
    p_biquad_cell->den.q2             = a2;
    p_biquad_cell->p_next             = NULL;
    if(p_IIR_filter->p_biquad_cell_list == NULL)
    {
        p_IIR_filter->p_biquad_cell_list = p_biquad_cell;
    }
    else
    {
        p_IIR_filter->p_last_biquad_cell->p_next = p_biquad_cell;
    }
    p_IIR_filter->p_last_biquad_cell = p_biquad_cell;

#ifdef MATLAB_TEQ_SHAI_CONFIG
    // save sampling rate and iirConfig for future use in TEQ_SHAI_compute_IIR()
    p_IIR_filter->nSamplingRate = nSamplingRate;
#endif // MATLAB_TEQ_SHAI_CONFIG

#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
    fprintf(debug_TEQ_SHAI_file[instance],
            "b0 = %+1.8f | b1 = %+1.8f | b2 = %+1.8f\n",
            p_biquad_cell->num.q0,
            p_biquad_cell->num.q1,
            p_biquad_cell->num.q2);
    fprintf(debug_TEQ_SHAI_file[instance],
            "a0 = %+1.8f | a1 = %+1.8f | a2 = %+1.8f\n",
            p_biquad_cell->den.q0,
            p_biquad_cell->den.q1,
            p_biquad_cell->den.q2);
    fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
    fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3

    return OMX_ErrorNone;
}


static OMX_ERRORTYPE compute_quad_roots(t_quad *p_quad, t_complex_root **p_p_complex_root, t_real_root **p_p_real_root, int instance)
{
    t_float a     = p_quad->q0;
    t_float b     = p_quad->q1;
    t_float c     = p_quad->q2;
    t_float delta = b * b - 4.0 * a * c;


#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
    fprintf(debug_TEQ_SHAI_file[instance], "Quad Roots :\n");
    fprintf(debug_TEQ_SHAI_file[instance], "q0 = %+1.8f\n", p_quad->q0);
    fprintf(debug_TEQ_SHAI_file[instance], "q1 = %+1.8f\n", p_quad->q1);
    fprintf(debug_TEQ_SHAI_file[instance], "q2 = %+1.8f\n", p_quad->q2);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
    p_p_complex_root[0] = NULL;
    p_p_complex_root[1] = NULL;
    p_p_real_root   [0] = NULL;
    p_p_real_root   [1] = NULL;
    if(delta < 0.0)
    {
        t_complex_root *p_complex_root1, *p_complex_root2;
        t_float        _2a, re, im, distance_to_unit_circle;

        p_complex_root1 = (t_complex_root *) my_malloc(sizeof(t_complex_root));
        if(p_complex_root1 == NULL)
        {
            return OMX_ErrorInsufficientResources;
        }
        p_complex_root2 = (t_complex_root *) my_malloc(sizeof(t_complex_root));
        if(p_complex_root2 == NULL)
        {
            my_free(p_complex_root1);
            return OMX_ErrorInsufficientResources;
        }
        _2a                                      = a + a;
        re                                       = -b           / _2a;
        im                                       = Sqrt(-delta) / _2a;
        // Sqrt(re * re + im * im) = Sqrt((b^2 - delta) / 4 / a^2) = Sqrt(c / a)
        distance_to_unit_circle                  = Fabs(/*Sqrt(re * re + im * im)*/ Sqrt(c / a) - 1.0);
        p_complex_root1->root.re                 = re;
        p_complex_root1->root.im                 = im;
        p_complex_root2->root.re                 = re;
        p_complex_root2->root.im                 = -im;
        p_complex_root1->distance_to_unit_circle = distance_to_unit_circle;
        p_complex_root2->distance_to_unit_circle = distance_to_unit_circle;
        // a.x^2+b.x+c = gain1.gain2.(x-root1).(x-root2) => gain1 = a, gain2 = 1 is a possible solution
        p_complex_root1->gain                    = a;
        p_complex_root2->gain                    = 1.0;
        p_p_complex_root[0]                      = p_complex_root1;
        p_p_complex_root[1]                      = p_complex_root2;
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
        fprintf(debug_TEQ_SHAI_file[instance],
                "root1 = %+1.8f %+1.8f * j | gain = %+1.8f | distance_to_unit_circle = %1.8f\n",
                p_complex_root1->root.re,
                p_complex_root1->root.im,
                p_complex_root1->gain,
                p_complex_root1->distance_to_unit_circle);
        fprintf(debug_TEQ_SHAI_file[instance],
                "root2 = %+1.8f %+1.8f * j | gain = %+1.8f | distance_to_unit_circle = %1.8f\n",
                p_complex_root2->root.re,
                p_complex_root2->root.im,
                p_complex_root2->gain,
                p_complex_root2->distance_to_unit_circle);
        fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
    }
    else if(a != 0.0)
    {
        t_real_root *p_real_root1, *p_real_root2;
        t_float     _2a, tmp1, tmp2;

        p_real_root1 = (t_real_root *) my_malloc(sizeof(t_real_root));
        if(p_real_root1 == NULL)
        {
            return OMX_ErrorInsufficientResources;
        }
        p_real_root2 = (t_real_root *) my_malloc(sizeof(t_real_root));
        if(p_real_root2 == NULL)
        {
            my_free(p_real_root1);
            return OMX_ErrorInsufficientResources;
        }
        _2a                                   = a + a;
        tmp1                                  = -b          / _2a;
        tmp2                                  = Sqrt(delta) / _2a;
        p_real_root1->root                    = tmp1 + tmp2;
        p_real_root2->root                    = tmp1 - tmp2;
        p_real_root1->distance_to_unit_circle = Fabs(Fabs(p_real_root1->root) - 1.0);
        p_real_root2->distance_to_unit_circle = Fabs(Fabs(p_real_root2->root) - 1.0);
        // a.x^2+b.x+c = gain1.gain2.(x-root1).(x-root2) => gain1 = a, gain2 = 1 is a possible solution
        p_real_root1->gain                    = a;
        p_real_root2->gain                    = 1.0;
        p_p_real_root[0]                      = p_real_root1;
        p_p_real_root[1]                      = p_real_root2;
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
        fprintf(debug_TEQ_SHAI_file[instance],
                "root1 = %+1.8f | gain = %+1.8f | distance_to_unit_circle = %1.8f\n",
                p_real_root1->root,
                p_real_root1->gain,
                p_real_root1->distance_to_unit_circle);
        fprintf(debug_TEQ_SHAI_file[instance],
                "root2 = %+1.8f | gain = %+1.8f | distance_to_unit_circle = %1.8f\n",
                p_real_root2->root,
                p_real_root2->gain,
                p_real_root2->distance_to_unit_circle);
        fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
    }
    else if(b != 0.0)
    {
        t_real_root *p_real_root;

        p_real_root = (t_real_root *) my_malloc(sizeof(t_real_root));
        if(p_real_root == NULL)
        {
            return OMX_ErrorInsufficientResources;
        }
        p_real_root->root                    = -c / b;
        p_real_root->distance_to_unit_circle = Fabs(Fabs(p_real_root->root) - 1.0);
        // b.x+c = gain.(x-root) => gain = b
        p_real_root->gain                    = b;
        p_p_real_root[0]                     = p_real_root;
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
        fprintf(debug_TEQ_SHAI_file[instance],
                "root = %+1.8f | gain = %+1.8f | distance_to_unit_circle = %1.8f\n",
                p_real_root->root,
                p_real_root->gain,
                p_real_root->distance_to_unit_circle);
        fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
    }
    else
    {
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
        fprintf(debug_TEQ_SHAI_file[instance], "error\n");
        fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
        fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
        return OMX_ErrorBadParameter;
    }
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
    fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4

    return OMX_ErrorNone;
}


static t_float square_dist_complex_complex(t_complex *p_cplx1, t_complex *p_cplx2)
{
    t_float re = p_cplx1->re - p_cplx2->re;
    t_float im = p_cplx1->im - p_cplx2->im;

    return (re * re + im * im);
}


static t_float square_dist_complex_real(t_complex *p_cplx, t_float real)
{
    t_float re = p_cplx->re - real;
    t_float im = p_cplx->im;

    return (re * re + im * im);
}


static t_float square_dist_real_real(t_float real1, t_float real2)
{
    t_float re = real1 - real2;

    return (re * re);
}


static void free_sort_temp(t_complex_root *p_complex_zeros, t_complex_root *p_complex_poles, t_real_root *p_real_zeros, t_real_root *p_real_poles, t_biquad_cell_float *p_biquad_cell_list)
{
    t_biquad_cell_float *p_biquad_cell, *p_biquad_cell_next;
    t_complex_root      *p_cplx, *p_cplx_next;
    t_real_root         *p_real, *p_real_next;

    for(p_cplx = p_complex_zeros; p_cplx != NULL; p_cplx = p_cplx_next)
    {
        p_cplx_next = p_cplx->p_next;
        my_free(p_cplx);
    }
    for(p_cplx = p_complex_poles; p_cplx != NULL; p_cplx = p_cplx_next)
    {
        p_cplx_next = p_cplx->p_next;
        my_free(p_cplx);
    }
    for(p_real = p_real_zeros; p_real != NULL; p_real = p_real_next)
    {
        p_real_next = p_real->p_next;
        my_free(p_real);
    }
    for(p_real = p_real_poles; p_real != NULL; p_real = p_real_next)
    {
        p_real_next = p_real->p_next;
        my_free(p_real);
    }
    for(p_biquad_cell = p_biquad_cell_list; p_biquad_cell != NULL; p_biquad_cell = p_biquad_cell_next)
    {
        p_biquad_cell_next = p_biquad_cell->p_next;
        my_free(p_biquad_cell);
    }
}


#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
static void debug_display_pole_pole(t_complex_root *p_complex_pole, t_complex_root *p_complex_zero, int instance)
{
    if((p_complex_pole != NULL) && (p_complex_zero != NULL))
    {
        fprintf(debug_TEQ_SHAI_file[instance],
                "\tcomplex pole = %+1.8f %+1.8f * j | complex zero = %+1.8f %+1.8f * j | distance = %1.8f\n",
                p_complex_pole->root.re,
                p_complex_pole->root.im,
                p_complex_zero->root.re,
                p_complex_zero->root.im,
                Sqrt(square_dist_complex_complex(&p_complex_pole->root, &p_complex_zero->root)));
    }
}


static void debug_display_pole_zero(t_complex_root *p_complex_pole, t_real_root *p_real_zero, int instance)
{
    if((p_complex_pole != NULL) && (p_real_zero != NULL))
    {
        fprintf(debug_TEQ_SHAI_file[instance],
                "\tcomplex pole = %+1.8f %+1.8f * j | real zero = %+1.8f | distance = %1.8f\n",
                p_complex_pole->root.re,
                p_complex_pole->root.im,
                p_real_zero->root,
                Sqrt(square_dist_complex_real(&p_complex_pole->root, p_real_zero->root)));
    }
}


static void debug_display_zero_pole(t_real_root *p_real_pole, t_complex_root *p_complex_zero, int instance)
{
    if((p_real_pole != NULL) && (p_complex_zero != NULL))
    {
        fprintf(debug_TEQ_SHAI_file[instance],
                "\treal pole = %+1.8f | complex zero = %+1.8f %+1.8f * j | distance = %1.8f\n",
                p_real_pole->root,
                p_complex_zero->root.re,
                p_complex_zero->root.im,
                Sqrt(square_dist_complex_real(&p_complex_zero->root, p_real_pole->root)));
    }
}


static void debug_display_zero_zero(t_real_root *p_real_pole, t_real_root *p_real_zero, int instance)
{
    if((p_real_pole != NULL) && (p_real_zero != NULL))
    {
        fprintf(debug_TEQ_SHAI_file[instance],
                "\treal pole = %+1.8f | real zero = %+1.8f | distance = %1.8f\n",
                p_real_pole->root,
                p_real_zero->root,
                Sqrt(square_dist_real_real(p_real_pole->root, p_real_zero->root)));
    }
}
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4


static OMX_ERRORTYPE compute_quad_from_roots(t_complex_root *p_complex_root[2], t_real_root *p_real_root[2], t_quad *p_quad)
{
    t_float gain, re1, re2, im1, im2;

    if((p_complex_root[0] == NULL) != (p_complex_root[1] == NULL))
    {
        // in a biquad cell, we must have 0 or 2 complex poles/zeros
        return OMX_ErrorUndefined;
    }
    else if((p_complex_root[0] != NULL) && (p_complex_root[1] != NULL))
    {
        gain = p_complex_root[0]->gain * p_complex_root[1]->gain;
        re1  = p_complex_root[0]->root.re;
        im1  = p_complex_root[0]->root.im;
        re2  = p_complex_root[1]->root.re;
        im2  = p_complex_root[1]->root.im;
        if(Fabs(re1 - re2) + Fabs(im1 + im2) > 0.0000001)
        {
            // if we have 2 complex poles/zeros, they must be conjugates
            return OMX_ErrorUndefined;
        }
    }
    else if((p_real_root[0] != NULL) && (p_real_root[1] != NULL))
    {
        gain = p_real_root[0]->gain * p_real_root[1]->gain;
        re1  = p_real_root[0]->root;
        im1  = 0.0;
        re2  = p_real_root[1]->root;
        im2  = 0.0;
    }
    else if((p_real_root[0] != NULL) && (p_real_root[1] == NULL))
    {
        gain = p_real_root[0]->gain;
        re1  = p_real_root[0]->root;
        im1  = 0.0;
        re2  = 0.0;
        im2  = 0.0;
    }
    else if((p_real_root[0] == NULL) && (p_real_root[1] != NULL))
    {
        gain = p_real_root[1]->gain;
        re1  = 0.0;
        im1  = 0.0;
        re2  = p_real_root[1]->root;
        im2  = 0.0;
    }
    else
    {
        gain = 1.0;
        re1  = 0.0;
        im1  = 0.0;
        re2  = 0.0;
        im2  = 0.0;
    }
    p_quad->q0 = gain;
    p_quad->q1 = gain * -(re1 + re2);
    p_quad->q2 = gain * (re1 * re2 - im1 * im2);

    return OMX_ErrorNone;
}


#define ZP2SOS_SORT_TYPE
// zp2sos matlab function does the same poles/zeros sort as sort_biquad routine above
// but when it reassembles poles and zeros into biquad cells, it insert each new biquad cell
// at the beginning of the list, so it reverts biquad list order.
// so sort_biquad with 'up' sort type is equivalent to zp2sos with 'down' sort type
// and sort_biquad with 'down' sort type is equivalent to zp2sos with 'up' sort type

static OMX_ERRORTYPE sort_biquad(t_biquad_cell_float *p_biquad_list, t_biquad_cell_float **p_p_biquad_list_sorted, t_biquad_sort biquad_sort, int instance)
{
    t_biquad_cell_float *p_biquad_cell, *p_biquad_cell_prev, *p_new_biquad_list = NULL;
    t_complex_root      *p_complex_zeros, *p_complex_zeros_list = NULL;
    t_complex_root      *p_complex_poles, *p_complex_poles_list = NULL;
    t_real_root         *p_real_zeros, *p_real_zeros_list = NULL;
    t_real_root         *p_real_poles, *p_real_poles_list = NULL;
    t_complex_root      *p1_cplx_prev, *p1_cplx, *p1_cplx_next, *p2_cplx_prev, *p2_cplx, *p2_cplx_next, *p_cplx_swap;
    t_real_root         *p1_real_prev, *p1_real, *p1_real_next, *p2_real_prev, *p2_real, *p2_real_next, *p_real_swap;
    t_float             dist1, dist2;
    OMX_ERRORTYPE       ret;
    int                 i;

    // create lists of complex zeros, complex poles, real zeros & real poles
    p1_cplx_prev = NULL;
    p2_cplx_prev = NULL;
    p1_real_prev = NULL;
    p2_real_prev = NULL;
    for(p_biquad_cell = p_biquad_list; p_biquad_cell != NULL; p_biquad_cell = p_biquad_cell->p_next)
    {
        for(i = 0; i < 2; i++)
        {
            if(p_biquad_cell->p_complex_zeros[i] != NULL)
            {
                p_complex_zeros = (t_complex_root *) my_malloc(sizeof(t_complex_root));
                if(p_complex_zeros == NULL)
                {
                    free_sort_temp(p_complex_zeros_list, p_complex_poles_list, p_real_zeros_list, p_real_poles_list, p_new_biquad_list);
                    return OMX_ErrorInsufficientResources;
                }
                *p_complex_zeros        = *p_biquad_cell->p_complex_zeros[i];
                p_complex_zeros->p_next = NULL;
                if(p1_cplx_prev == NULL)
                {
                    p_complex_zeros_list = p_complex_zeros;
                }
                else
                {
                    p1_cplx_prev->p_next = p_complex_zeros;
                }
                p1_cplx_prev = p_complex_zeros;
            }
            if(p_biquad_cell->p_complex_poles[i] != NULL)
            {
                p_complex_poles = (t_complex_root *) my_malloc(sizeof(t_complex_root));
                if(p_complex_poles == NULL)
                {
                    free_sort_temp(p_complex_zeros_list, p_complex_poles_list, p_real_zeros_list, p_real_poles_list, p_new_biquad_list);
                    return OMX_ErrorInsufficientResources;
                }
                *p_complex_poles        = *p_biquad_cell->p_complex_poles[i];
                p_complex_poles->p_next = NULL;
                if(p2_cplx_prev == NULL)
                {
                    p_complex_poles_list = p_complex_poles;
                }
                else
                {
                    p2_cplx_prev->p_next = p_complex_poles;
                }
                p2_cplx_prev = p_complex_poles;
            }
            if(p_biquad_cell->p_real_zeros[i] != NULL)
            {
                p_real_zeros = (t_real_root *) my_malloc(sizeof(t_real_root));
                if(p_real_zeros == NULL)
                {
                    free_sort_temp(p_complex_zeros_list, p_complex_poles_list, p_real_zeros_list, p_real_poles_list, p_new_biquad_list);
                    return OMX_ErrorInsufficientResources;
                }
                *p_real_zeros        = *p_biquad_cell->p_real_zeros[i];
                p_real_zeros->p_next = NULL;
                if(p1_real_prev == NULL)
                {
                    p_real_zeros_list    = p_real_zeros;
                }
                else
                {
                    p1_real_prev->p_next = p_real_zeros;
                }
                p1_real_prev = p_real_zeros;
            }
            if(p_biquad_cell->p_real_poles[i] != NULL)
            {
                p_real_poles = (t_real_root *) my_malloc(sizeof(t_real_root));
                if(p_real_poles == NULL)
                {
                    free_sort_temp(p_complex_zeros_list, p_complex_poles_list, p_real_zeros_list, p_real_poles_list, p_new_biquad_list);
                    return OMX_ErrorInsufficientResources;
                }
                *p_real_poles        = *p_biquad_cell->p_real_poles[i];
                p_real_poles->p_next = NULL;
                if(p2_real_prev == NULL)
                {
                    p_real_poles_list    = p_real_poles;
                }
                else
                {
                    p2_real_prev->p_next = p_real_poles;
                }
                p2_real_prev = p_real_poles;
            }
        }
    }
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 5
    fprintf(debug_TEQ_SHAI_file[instance], "Sort biquads step 1 : create lists of complex zeros, complex poles, real zeros & real poles\n");
    for(p_complex_zeros = p_complex_zeros_list, i = 0; p_complex_zeros != NULL; p_complex_zeros = p_complex_zeros->p_next, i++)
    {
        fprintf(debug_TEQ_SHAI_file[instance],
                "\tcomplex zero %d = %+1.8f %+1.8f * j | gain = %+1.8f | distance_to_unit_circle = %1.8f\n",
                i,
                p_complex_zeros->root.re,
                p_complex_zeros->root.im,
                p_complex_zeros->gain,
                p_complex_zeros->distance_to_unit_circle);
    }
    for(p_complex_poles = p_complex_poles_list, i = 0; p_complex_poles != NULL; p_complex_poles = p_complex_poles->p_next, i++)
    {
        fprintf(debug_TEQ_SHAI_file[instance],
                "\tcomplex pole %d = %+1.8f %+1.8f * j | gain = %+1.8f | distance_to_unit_circle = %1.8f\n",
                i,
                p_complex_poles->root.re,
                p_complex_poles->root.im,
                p_complex_poles->gain,
                p_complex_poles->distance_to_unit_circle);
    }
    for(p_real_zeros = p_real_zeros_list, i = 0; p_real_zeros != NULL; p_real_zeros = p_real_zeros->p_next, i++)
    {
        fprintf(debug_TEQ_SHAI_file[instance],
                "\treal zero %d = %+1.8f | gain = %+1.8f | distance_to_unit_circle = %1.8f\n",
                i,
                p_real_zeros->root,
                p_real_zeros->gain,
                p_real_zeros->distance_to_unit_circle);
    }
    for(p_real_poles = p_real_poles_list, i = 0; p_real_poles != NULL; p_real_poles = p_real_poles->p_next, i++)
    {
        fprintf(debug_TEQ_SHAI_file[instance],
                "\treal pole %d = %+1.8f | gain = %+1.8f | distance_to_unit_circle = %1.8f\n",
                i,
                p_real_poles->root,
                p_real_poles->gain,
                p_real_poles->distance_to_unit_circle);
    }
    fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 5

    if(biquad_sort != BIQUAD_NO_SORT)
    {
        // sort list of complex poles
        p1_cplx_prev = NULL;
        for(p1_cplx = p_complex_poles_list; p1_cplx != NULL; p1_cplx = p1_cplx_next)
        {
            p1_cplx_next = p1_cplx->p_next;
            dist1        = p1_cplx->distance_to_unit_circle;
            p2_cplx_prev = p1_cplx;
            for(p2_cplx = p1_cplx->p_next; p2_cplx != NULL; p2_cplx = p2_cplx_next)
            {
                p2_cplx_next = p2_cplx->p_next;
                dist2        = p2_cplx->distance_to_unit_circle;
#ifdef ZP2SOS_SORT_TYPE
                if(dist2 < dist1)
#else // ZP2SOS_SORT_TYPE
                if(   ((biquad_sort == BIQUAD_DOWN_SORT) && (dist2 > dist1))
                   || ((biquad_sort == BIQUAD_UP_SORT)   && (dist2 < dist1)))
#endif // ZP2SOS_SORT_TYPE
                {
                    if(p1_cplx_prev == NULL)
                    {
                        p_complex_poles_list = p2_cplx;
                    }
                    else
                    {
                        p1_cplx_prev->p_next = p2_cplx;
                    }
                    if(p1_cplx_next == p2_cplx)
                    {
                        p2_cplx->p_next      = p1_cplx;
                    }
                    else
                    {
                        p2_cplx->p_next      = p1_cplx_next;
                        p2_cplx_prev->p_next = p1_cplx;
                    }
                    p1_cplx->p_next          = p2_cplx_next;
                    p_cplx_swap              = p1_cplx;
                    p1_cplx                  = p2_cplx;
                    p2_cplx                  = p_cplx_swap;
                    p1_cplx_next             = p1_cplx->p_next;
                    p2_cplx_next             = p2_cplx->p_next;
                    dist1                    = dist2;
                }
                p2_cplx_prev = p2_cplx;
            }
            p1_cplx_prev = p1_cplx;
        }

        // sort list of real poles
        p1_real_prev = NULL;
        for(p1_real = p_real_poles_list; p1_real != NULL; p1_real = p1_real_next)
        {
            p1_real_next = p1_real->p_next;
            dist1        = p1_real->distance_to_unit_circle;
            p2_real_prev = p1_real;
            for(p2_real = p1_real->p_next; p2_real != NULL; p2_real = p2_real_next)
            {
                p2_real_next = p2_real->p_next;
                dist2        = p2_real->distance_to_unit_circle;
#ifdef ZP2SOS_SORT_TYPE
                if(dist2 < dist1)
#else // ZP2SOS_SORT_TYPE
                if(   ((biquad_sort == BIQUAD_DOWN_SORT) && (dist2 > dist1))
                   || ((biquad_sort == BIQUAD_UP_SORT)   && (dist2 < dist1)))
#endif // ZP2SOS_SORT_TYPE
                {
                    if(p1_real_prev == NULL)
                    {
                        p_real_poles_list    = p2_real;
                    }
                    else
                    {
                        p1_real_prev->p_next = p2_real;
                    }
                    if(p1_real_next == p2_real)
                    {
                        p2_real->p_next      = p1_real;
                    }
                    else
                    {
                        p2_real->p_next      = p1_real_next;
                        p2_real_prev->p_next = p1_real;
                    }
                    p1_real->p_next          = p2_real_next;
                    p_real_swap              = p1_real;
                    p1_real                  = p2_real;
                    p2_real                  = p_real_swap;
                    p1_real_next             = p1_real->p_next;
                    p2_real_next             = p2_real->p_next;
                    dist1                    = dist2;
                }
                p2_real_prev = p2_real;
            }
            p1_real_prev = p1_real;
        }
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 5
#ifdef ZP2SOS_SORT_TYPE
        fprintf(debug_TEQ_SHAI_file[instance], "\nSort biquads step 2 : sort UP lists of complex poles & real poles\n");
#else // ZP2SOS_SORT_TYPE
        fprintf(debug_TEQ_SHAI_file[instance], "\nSort biquads step 2 : sort %s lists of complex poles & real poles\n", (biquad_sort == BIQUAD_DOWN_SORT ? "DOWN" : "UP"));
#endif // ZP2SOS_SORT_TYPE
        for(p_complex_poles = p_complex_poles_list, i = 0; p_complex_poles != NULL; p_complex_poles = p_complex_poles->p_next, i++)
        {
            fprintf(debug_TEQ_SHAI_file[instance],
                    "\tcomplex pole %d = %+1.8f %+1.8f * j | gain = %+1.8f | distance_to_unit_circle = %1.8f\n",
                    i,
                    p_complex_poles->root.re,
                    p_complex_poles->root.im,
                    p_complex_poles->gain,
                    p_complex_poles->distance_to_unit_circle);
        }
        for(p_real_poles = p_real_poles_list, i = 0; p_real_poles != NULL; p_real_poles = p_real_poles->p_next, i++)
        {
            fprintf(debug_TEQ_SHAI_file[instance],
                    "\treal pole %d = %+1.8f | gain = %+1.8f | distance_to_unit_circle = %1.8f\n",
                    i,
                    p_real_poles->root,
                    p_real_poles->gain,
                    p_real_poles->distance_to_unit_circle);
        }
        fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 5

        // select zeros closest to poles (beginning with complex lists, then real lists)
        p1_cplx_prev = NULL;
        p1_real_prev = NULL;
        for(p_complex_poles = p_complex_poles_list; p_complex_poles != NULL; p_complex_poles = p_complex_poles->p_next)
        {
            p1_cplx = (p1_cplx_prev == NULL ? p_complex_zeros_list : p1_cplx_prev->p_next);
            if(p1_cplx != NULL)
            {
                p1_cplx_next = p1_cplx->p_next;
                dist1        = square_dist_complex_complex(&p_complex_poles->root, &p1_cplx->root);
                p2_cplx_prev = p1_cplx;
                for(p2_cplx = p1_cplx_next; p2_cplx != NULL; p2_cplx = p2_cplx_next)
                {
                    p2_cplx_next = p2_cplx->p_next;
                    dist2        = square_dist_complex_complex(&p_complex_poles->root, &p2_cplx->root);
                    if(dist2 < dist1)
                    {
                        if(p1_cplx_prev == NULL)
                        {
                            p_complex_zeros_list = p2_cplx;
                        }
                        else
                        {
                            p1_cplx_prev->p_next = p2_cplx;
                        }
                        if(p1_cplx_next == p2_cplx)
                        {
                            p2_cplx->p_next      = p1_cplx;
                        }
                        else
                        {
                            p2_cplx->p_next      = p1_cplx_next;
                            p2_cplx_prev->p_next = p1_cplx;
                        }
                        p1_cplx->p_next          = p2_cplx_next;
                        p_cplx_swap              = p1_cplx;
                        p1_cplx                  = p2_cplx;
                        p2_cplx                  = p_cplx_swap;
                        p1_cplx_next             = p1_cplx->p_next;
                        p2_cplx_next             = p2_cplx->p_next;
                        dist1                    = dist2;
                    }
                    p2_cplx_prev = p2_cplx;
                }
                p1_cplx_prev = p1_cplx;
            }
            if(p1_cplx == NULL)
            {
                p1_real = (p1_real_prev == NULL ? p_real_zeros_list : p1_real_prev->p_next);
                if(p1_real != NULL)
                {
                    p1_real_next = p1_real->p_next;
                    dist1        = square_dist_complex_real(&p_complex_poles->root, p1_real->root);
                    p2_real_prev = p1_real;
                    for(p2_real = p1_real_next; p2_real != NULL; p2_real = p2_real_next)
                    {
                        p2_real_next = p2_real->p_next;
                        dist2        = square_dist_complex_real(&p_complex_poles->root, p2_real->root);
                        if(dist2 < dist1)
                        {
                            if(p1_real_prev == NULL)
                            {
                                p_real_zeros_list    = p2_real;
                            }
                            else
                            {
                                p1_real_prev->p_next = p2_real;
                            }
                            if(p1_real_next == p2_real)
                            {
                                p2_real->p_next      = p1_real;
                            }
                            else
                            {
                                p2_real->p_next      = p1_real_next;
                                p2_real_prev->p_next = p1_real;
                            }
                            p1_real->p_next          = p2_real_next;
                            p_real_swap              = p1_real;
                            p1_real                  = p2_real;
                            p2_real                  = p_real_swap;
                            p1_real_next             = p1_real->p_next;
                            p2_real_next             = p2_real->p_next;
                            dist1                    = dist2;
                        }
                        p2_real_prev = p2_real;
                    }
                    p1_real_prev = p1_real;
                }
                if(p1_real == NULL)
                {
                    break;
                }
            }
        }
        for(p_real_poles = p_real_poles_list; p_real_poles != NULL; p_real_poles = p_real_poles->p_next)
        {
            p1_cplx = (p1_cplx_prev == NULL ? p_complex_zeros_list : p1_cplx_prev->p_next);
            if(p1_cplx != NULL)
            {
                p1_cplx_next = p1_cplx->p_next;
                dist1        = square_dist_complex_real(&p1_cplx->root, p_real_poles->root);
                p2_cplx_prev = p1_cplx;
                for(p2_cplx = p1_cplx_next; p2_cplx != NULL; p2_cplx = p2_cplx_next)
                {
                    p2_cplx_next = p2_cplx->p_next;
                    dist2        = square_dist_complex_real(&p2_cplx->root, p_real_poles->root);
                    if(dist2 < dist1)
                    {
                        if(p1_cplx_prev == NULL)
                        {
                            p_complex_zeros_list = p2_cplx;
                        }
                        else
                        {
                            p1_cplx_prev->p_next = p2_cplx;
                        }
                        if(p1_cplx_next == p2_cplx)
                        {
                            p2_cplx->p_next      = p1_cplx;
                        }
                        else
                        {
                            p2_cplx->p_next      = p1_cplx_next;
                            p2_cplx_prev->p_next = p1_cplx;
                        }
                        p1_cplx->p_next          = p2_cplx_next;
                        p_cplx_swap              = p1_cplx;
                        p1_cplx                  = p2_cplx;
                        p2_cplx                  = p_cplx_swap;
                        p1_cplx_next             = p1_cplx->p_next;
                        p2_cplx_next             = p2_cplx->p_next;
                        dist1                    = dist2;
                    }
                    p2_cplx_prev = p2_cplx;
                }
                p1_cplx_prev = p1_cplx;
            }
            if(p1_cplx == NULL)
            {
                p1_real = (p1_real_prev == NULL ? p_real_zeros_list : p1_real_prev->p_next);
                if(p1_real != NULL)
                {
                    p1_real_next = p1_real->p_next;
                    dist1        = square_dist_real_real(p_real_poles->root, p1_real->root);
                    p2_real_prev = p1_real;
                    for(p2_real = p1_real_next; p2_real != NULL; p2_real = p2_real_next)
                    {
                        p2_real_next = p2_real->p_next;
                        dist2        = square_dist_real_real(p_real_poles->root, p2_real->root);
                        if(dist2 < dist1)
                        {
                            if(p1_real_prev == NULL)
                            {
                                p_real_zeros_list    = p2_real;
                            }
                            else
                            {
                                p1_real_prev->p_next = p2_real;
                            }
                            if(p1_real_next == p2_real)
                            {
                                p2_real->p_next      = p1_real;
                            }
                            else
                            {
                                p2_real->p_next      = p1_real_next;
                                p2_real_prev->p_next = p1_real;
                            }
                            p1_real->p_next          = p2_real_next;
                            p_real_swap              = p1_real;
                            p1_real                  = p2_real;
                            p2_real                  = p_real_swap;
                            p1_real_next             = p1_real->p_next;
                            p2_real_next             = p2_real->p_next;
                            dist1                    = dist2;
                        }
                        p2_real_prev = p2_real;
                    }
                    p1_real_prev = p1_real;
                }
                if(p1_real == NULL)
                {
                    break;
                }
            }
        }
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 5
        fprintf(debug_TEQ_SHAI_file[instance], "\nSort biquads step 3 : select zeros closest to poles (beginning with complex lists, then real lists)\n");
        for(p_complex_zeros = p_complex_zeros_list, i = 0; p_complex_zeros != NULL; p_complex_zeros = p_complex_zeros->p_next, i++)
        {
            fprintf(debug_TEQ_SHAI_file[instance],
                    "\tcomplex zero %d = %+1.8f %+1.8f * j\n",
                    i,
                    p_complex_zeros->root.re,
                    p_complex_zeros->root.im);
        }
        for(p_real_zeros = p_real_zeros_list, i = 0; p_real_zeros != NULL; p_real_zeros = p_real_zeros->p_next, i++)
        {
            fprintf(debug_TEQ_SHAI_file[instance],
                    "\treal zero %d = %+1.8f\n",
                    i,
                    p_real_zeros->root);
        }
        fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 5
    }

    // re-arrange biquads according to sorting
    p_complex_zeros    = p_complex_zeros_list;
    p_complex_poles    = p_complex_poles_list;
    p_real_zeros       = p_real_zeros_list;
    p_real_poles       = p_real_poles_list;
    p_biquad_cell_prev = NULL;
    while(   (p_complex_zeros != NULL)
          || (p_complex_poles != NULL)
          || (p_real_zeros    != NULL)
          || (p_real_poles    != NULL))
    {
        p_biquad_cell = (t_biquad_cell_float *) my_malloc(sizeof(t_biquad_cell_float));
        if(p_biquad_cell == NULL)
        {
            free_sort_temp(p_complex_zeros_list, p_complex_poles_list, p_real_zeros_list, p_real_poles_list, p_new_biquad_list);
            return OMX_ErrorInsufficientResources;
        }
        p_biquad_cell->p_next = NULL;
        if(p_new_biquad_list == NULL)
        {
            p_new_biquad_list = p_biquad_cell;
        }
        else
        {
            p_biquad_cell_prev->p_next = p_biquad_cell;
        }
        for(i = 0; i < 2; i++)
        {
            p_biquad_cell->p_complex_poles[i] = NULL;
            p_biquad_cell->p_real_poles   [i] = NULL;
            p_biquad_cell->p_complex_zeros[i] = NULL;
            p_biquad_cell->p_real_zeros   [i] = NULL;
            if(p_complex_poles != NULL)
            {
                p_biquad_cell->p_complex_poles[i] = p_complex_poles;
                p_complex_poles = p_complex_poles->p_next;
            }
            else if(p_real_poles != NULL)
            {
                p_biquad_cell->p_real_poles[i] = p_real_poles;
                p_real_poles = p_real_poles->p_next;
            }
            if(p_complex_zeros != NULL)
            {
                p_biquad_cell->p_complex_zeros[i] = p_complex_zeros;
                p_complex_zeros = p_complex_zeros->p_next;
            }
            else if(p_real_zeros != NULL)
            {
                p_biquad_cell->p_real_zeros[i] = p_real_zeros;
                p_real_zeros = p_real_zeros->p_next;
            }
        }
        p_biquad_cell_prev = p_biquad_cell;
    }
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
    fprintf(debug_TEQ_SHAI_file[instance], "\nSort biquads step 4 : re-arrange biquads according to sorting\n");
    for(p_biquad_cell = p_new_biquad_list, i = 0; p_biquad_cell != NULL; p_biquad_cell = p_biquad_cell->p_next, i++)
    {
        fprintf(debug_TEQ_SHAI_file[instance], "biquad %d :\n", i);
        debug_display_pole_pole(p_biquad_cell->p_complex_poles[0], p_biquad_cell->p_complex_zeros[0], instance);
        debug_display_pole_zero(p_biquad_cell->p_complex_poles[0], p_biquad_cell->p_real_zeros   [0], instance);
        debug_display_zero_pole(p_biquad_cell->p_real_poles   [0], p_biquad_cell->p_complex_zeros[0], instance);
        debug_display_zero_zero(p_biquad_cell->p_real_poles   [0], p_biquad_cell->p_real_zeros   [0], instance);
        debug_display_pole_pole(p_biquad_cell->p_complex_poles[1], p_biquad_cell->p_complex_zeros[1], instance);
        debug_display_pole_zero(p_biquad_cell->p_complex_poles[1], p_biquad_cell->p_real_zeros   [1], instance);
        debug_display_zero_pole(p_biquad_cell->p_real_poles   [1], p_biquad_cell->p_complex_zeros[1], instance);
        debug_display_zero_zero(p_biquad_cell->p_real_poles   [1], p_biquad_cell->p_real_zeros   [1], instance);
    }
    fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4

    // recomputes biquad coefficents from roots
    for(p_biquad_cell = p_new_biquad_list; p_biquad_cell != NULL; p_biquad_cell = p_biquad_cell->p_next)
    {
        ret = compute_quad_from_roots(p_biquad_cell->p_complex_poles, p_biquad_cell->p_real_poles, &p_biquad_cell->den);
        if(ret != OMX_ErrorNone)
        {
            free_sort_temp(p_complex_zeros_list, p_complex_poles_list, p_real_zeros_list, p_real_poles_list, p_new_biquad_list);
            return ret;
        }
        ret = compute_quad_from_roots(p_biquad_cell->p_complex_zeros, p_biquad_cell->p_real_zeros, &p_biquad_cell->num);
        if(ret != OMX_ErrorNone)
        {
            free_sort_temp(p_complex_zeros_list, p_complex_poles_list, p_real_zeros_list, p_real_poles_list, p_new_biquad_list);
            return ret;
        }
    }
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
    fprintf(debug_TEQ_SHAI_file[instance], "\nSort biquads step 5 : recomputes biquad coefficents from roots\n");
    for(p_biquad_cell = p_new_biquad_list, i = 0; p_biquad_cell != NULL; p_biquad_cell = p_biquad_cell->p_next, i++)
    {
        fprintf(debug_TEQ_SHAI_file[instance], "biquad %d :\n", i);
        fprintf(debug_TEQ_SHAI_file[instance],
                "\tb0 = %+1.8f | b1 = %+1.8f | b2 = %+1.8f\n",
                p_biquad_cell->num.q0,
                p_biquad_cell->num.q1,
                p_biquad_cell->num.q2);
        fprintf(debug_TEQ_SHAI_file[instance],
                "\ta0 = %+1.8f | a1 = %+1.8f | a2 = %+1.8f\n",
                p_biquad_cell->den.q0,
                p_biquad_cell->den.q1,
                p_biquad_cell->den.q2);
    }
    fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
    fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4

#ifdef ZP2SOS_SORT_TYPE
    if((p_new_biquad_list != NULL) && (biquad_sort == BIQUAD_DOWN_SORT))
    {
        // revert biquad list order
        t_biquad_cell_float *p_biquad_cell_next;

        p_biquad_cell_prev = NULL;
        p_biquad_cell      = p_new_biquad_list;
        p_biquad_cell_next = p_biquad_cell->p_next;
        while(p_biquad_cell_next != NULL)
        {
            p_new_biquad_list          = p_biquad_cell_next->p_next;
            p_biquad_cell_next->p_next = p_biquad_cell;
            p_biquad_cell->p_next      = p_biquad_cell_prev;
            p_biquad_cell_prev         = p_biquad_cell;
            p_biquad_cell              = p_biquad_cell_next;
            p_biquad_cell_next         = p_new_biquad_list;
        }
        p_new_biquad_list = p_biquad_cell;
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
        fprintf(debug_TEQ_SHAI_file[instance], "\nSort biquads step 6 : revert biquad list order for DOWN sort\n");
        for(p_biquad_cell = p_new_biquad_list, i = 0; p_biquad_cell != NULL; p_biquad_cell = p_biquad_cell->p_next, i++)
        {
            fprintf(debug_TEQ_SHAI_file[instance], "biquad %d :\n", i);
            fprintf(debug_TEQ_SHAI_file[instance],
                    "\tb0 = %+1.8f | b1 = %+1.8f | b2 = %+1.8f\n",
                    p_biquad_cell->num.q0,
                    p_biquad_cell->num.q1,
                    p_biquad_cell->num.q2);
            fprintf(debug_TEQ_SHAI_file[instance],
                    "\ta0 = %+1.8f | a1 = %+1.8f | a2 = %+1.8f\n",
                    p_biquad_cell->den.q0,
                    p_biquad_cell->den.q1,
                    p_biquad_cell->den.q2);
        }
        fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
        fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
    }
#endif // ZP2SOS_SORT_TYPE

    *p_p_biquad_list_sorted = p_new_biquad_list;

    return OMX_ErrorNone;
}


static t_float module_max_biquad(t_float b0, t_float b1, t_float b2, t_float a1, t_float a2, t_float **p_p_module2)
{
    /*********************************************************************************************************************************

                     || b0 + b1.exp(-j.w) + b2.exp(-2.j.w) ||
    ||H(exp(j.w)|| = ||------------------------------------||
                     || 1  + a1.exp(-j.w) + a2.exp(-2.j.w) ||

                     || b0 + b1.cos(w) + b2.cos(2.w) -j.(b1.sin(w) + b2.sin(2.w))  ||
                   = ||----------------------------------------------------------- ||
                     || 1  + a1.cos(w) + a2.cos(2.w) -j.(a1.sin(w) + a2.sin(2.w))  ||

                     [ (b0 + b1.cos(w) + b2.cos(2.w))^2 + (b1.sin(w) + b2.sin(2.w))^2  ]^1/2
                   = [---------------------------------------------------------------- ]
                     [ (1  + a1.cos(w) + a2.cos(2.w))^2 + (a1.sin(w) + a2.sin(2.w))^2  ]

                     [ b0^2 + b1^2 + b2^2 + 2.b0.b1.cos(w) + 2.b0.b2.cos(2.w) + 2.b1.b2.(cos(w).cos(2.w) + sin(w).sin(2.w))  ]^1/2
                   = [------------------------------------------------------------------------------------------------------ ]
                     [  1   + a1^2 + a2^2 +    2.a1.cos(w) +    2.a2.cos(2.w) + 2.a1.a2.(cos(w).cos(2.w) + sin(w).sin(2.w))  ]

                     [ b0^2 + b1^2 + b2^2 + 2.b0.b1.cos(w) + 2.b0.b2.cos(2.w) + 2.b1.b2.cos(w)  ]^1/2
                   = [------------------------------------------------------------------------- ]
                     [  1   + a1^2 + a2^2 +    2.a1.cos(w) +    2.a2.cos(2.w) + 2.a1.a2.cos(w)  ]

                     [ b0^2 + b1^2 + b2^2 + 2.b1.(b0 + b2).cos(w) + 2.b0.b2.cos(2.w)  ]^1/2
                   = [--------------------------------------------------------------- ]
                     [  1   + a1^2 + a2^2 + 2.a1.( 1 + a2).cos(w) +    2.a2.cos(2.w)  ]

    *********************************************************************************************************************************/
    int     i;
    t_float cos1, cos2, module2, module2_max, coef;
    t_float t0, t1, t2, t3, t4, t5;
    t_float *p_module2;

    p_module2 = *p_p_module2;
    if(p_module2 == NULL)
    {
        *p_p_module2 = p_module2 = (t_float *) my_malloc((COS_TABLE_SIZE / 2) * sizeof(t_float));
        if(p_module2 == NULL)
        {
            return -1.0;
        }
        for(i = 0; i < (COS_TABLE_SIZE / 2); i++)
        {
            p_module2[i] = 1.0;
        }
    }

    t0          = b0 * b0 + b1 * b1 + b2 * b2;
    t1          = 2.0 * b1 * (b0 + b2);
    t2          = 2.0 * b0 * b2;
    t3          = 1.0 + a1 * a1 + a2 * a2;
    t4          = 2.0 * a1 * (1.0 + a2);
    t5          = 2.0 * a2;
    module2_max = 0.0;
    for(i = 0; i < (COS_TABLE_SIZE / 2); i++)
    {
        cos1         = cos_table[i];        // modulo is useless (cos_table size won't be exceeded)
        cos2         = cos_table[i * 2];    //
        module2      = p_module2[i] * (t0 + t1 * cos1 + t2 * cos2) / (t3 + t4 * cos1 + t5 * cos2);
        p_module2[i] = module2;
        module2_max  = max(module2_max, module2);
    }

    coef = 1.0 / module2_max;
    for(i = 0; i < (COS_TABLE_SIZE / 2); i++)
    {
        p_module2[i] *= coef;
    }

    return Sqrt(module2_max);
}


static OMX_ERRORTYPE normalize_biquad_cells(t_biquad_cell_float *p_biquad_cell_list, t_float *p_gain, int instance)
{
    t_biquad_cell_float *p_biquad_cell;
    t_float             b0, b1, b2, a0, a1, a2;
    t_float             *p_module2, global_gain, biquad_gain;

    p_module2   = NULL;
    global_gain = 1.0;
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
    fprintf(debug_TEQ_SHAI_file[instance], "normalize_biquad_cells :\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
    for(p_biquad_cell = p_biquad_cell_list; p_biquad_cell != NULL; p_biquad_cell = p_biquad_cell->p_next)
    {
        a0          = p_biquad_cell->den.q0;
        a1          = p_biquad_cell->den.q1 / a0;
        a2          = p_biquad_cell->den.q2 / a0;
        b0          = p_biquad_cell->num.q0 / a0;
        b1          = p_biquad_cell->num.q1 / a0;
        b2          = p_biquad_cell->num.q2 / a0;
        biquad_gain = module_max_biquad(b0, b1, b2, a1, a2, &p_module2);
        if(p_module2 == NULL)
        {
            return OMX_ErrorInsufficientResources;
        }
        p_biquad_cell->den.q0 = 1.0;
        p_biquad_cell->den.q1 = a1;
        p_biquad_cell->den.q2 = a2;
        p_biquad_cell->num.q0 = b0 / biquad_gain;
        p_biquad_cell->num.q1 = b1 / biquad_gain;
        p_biquad_cell->num.q2 = b2 / biquad_gain;
        global_gain          *= biquad_gain;
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
        fprintf(debug_TEQ_SHAI_file[instance], "biquad_gain = %1.8f, global_gain = %1.8f\n", biquad_gain, global_gain);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
    }
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
    fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
    fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3

    *p_gain = global_gain;
    my_free(p_module2);

    return OMX_ErrorNone;
}


static OMX_ERRORTYPE check_biquad_stability(int nb_cells, t_IIR_filter_quantified *p_IIR_filter_quantified, int nb_bits_quantif, int instance)
{
    OMX_ERRORTYPE error = OMX_ErrorNone;
    int           i, stability;
    t_float       *p_module2;
    t_float       gain_a, gain_b, b0, b1, b2, a1, a2, delta, sqrt_delta, re, im, p1, p2, pole_module, biquad_gain;


#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
    fprintf(debug_TEQ_SHAI_file[instance], "check_biquad_stability :\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3

    p_module2 = NULL;
    gain_a  = Pow2(-31.0);
    for(i = 0; i < nb_cells; i++)
    {
        gain_b      = Pow2((t_float) (p_IIR_filter_quantified->biquad_cell[i].b_exp - 31));
        b0          = ((t_float)      p_IIR_filter_quantified->biquad_cell[i].b0) * gain_b;
        b1          = ((t_float)      p_IIR_filter_quantified->biquad_cell[i].b1) * gain_b;
        b2          = ((t_float)      p_IIR_filter_quantified->biquad_cell[i].b2) * gain_b;
        a1          = ((t_float)      p_IIR_filter_quantified->biquad_cell[i].a1) * gain_a * 2.0;
        a2          = ((t_float)      p_IIR_filter_quantified->biquad_cell[i].a2) * gain_a;
        delta       = a1 * a1 - 4.0 * a2;
        if(delta < 0.0)
        {
            sqrt_delta  = Sqrt(-delta);
            re          = -a1        * 0.5;
            im          = sqrt_delta * 0.5;
            pole_module = Sqrt(re * re + im * im);
            p1 = p2 = 0.0;  // to remove warnings
        }
        else
        {
            sqrt_delta  = Sqrt(delta);
            p1          = (-a1 - sqrt_delta) * 0.5;
            p2          = (-a1 + sqrt_delta) * 0.5;
            pole_module = (a1 > 0.0 ? -p1 : p2);
            re = im = 0.0;  // to remove warnings
        }
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
        fprintf(debug_TEQ_SHAI_file[instance], "pole_module %d = %1.8f\n", i, pole_module);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
        if(pole_module > 0.999)
        {
            // recompute poles to be inside unit circle
            t_float coef  = 0.999 / pole_module;

            a1                                        *= coef;
            a2                                        *= coef * coef;
            p_IIR_filter_quantified->biquad_cell[i].a1 = float2Q31(a1 * 0.5, nb_bits_quantif);
            p_IIR_filter_quantified->biquad_cell[i].a2 = float2Q31(a2      , nb_bits_quantif);
            a1                                         = ((t_float) p_IIR_filter_quantified->biquad_cell[i].a1) * gain_a * 2.0;
            a2                                         = ((t_float) p_IIR_filter_quantified->biquad_cell[i].a2) * gain_a;
            delta = a1 * a1 - 4.0 * a2;
            if(delta < 0.0)
            {
                sqrt_delta  = Sqrt(-delta);
                re          = -a1        * 0.5;
                im          = sqrt_delta * 0.5;
                pole_module = Sqrt(re * re + im * im);
            }
            else
            {
                sqrt_delta  = Sqrt(delta);
                p1          = (-a1 - sqrt_delta) * 0.5;
                p2          = (-a1 + sqrt_delta) * 0.5;
                pole_module = (a1 > 0.0 ? -p1 : p2);
            }
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            fprintf(debug_TEQ_SHAI_file[instance], "new pole_module %d = %1.8f\n", i, pole_module);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
        }
        stability   = (pole_module < 1.0);                                                  // poles inside unit circle
        stability   = stability && (a2 <= 1.0) && (a2 >= a1 - 1.0) && (a2 >= -a1 - 1.0);    // stability triangle : see http://www.cs.washington.edu/education/courses/cse490s/11au/Readings/Digital_Sound_Generation_2.pdf 3.5.3
        biquad_gain = module_max_biquad(b0, b1, b2, a1, a2, &p_module2);
        if(p_module2 == NULL)
        {
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            fprintf(debug_TEQ_SHAI_file[instance], "p_module2 == NULL => OMX_ErrorInsufficientResources\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            error = OMX_ErrorInsufficientResources;
            break;
        }
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
        fprintf(debug_TEQ_SHAI_file[instance],
                "b_exp=%+2d - b0=0x%08X - b1=0x%08X - b2=0x%08X - a1=0x%08X - a2=0x%08X => gain=%1.8f\n",
                (int) p_IIR_filter_quantified->biquad_cell[i].b_exp,
                (int) p_IIR_filter_quantified->biquad_cell[i].b0,
                (int) p_IIR_filter_quantified->biquad_cell[i].b1,
                (int) p_IIR_filter_quantified->biquad_cell[i].b2,
                (int) p_IIR_filter_quantified->biquad_cell[i].a1,
                (int) p_IIR_filter_quantified->biquad_cell[i].a2,
                biquad_gain);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
        if((biquad_gain > 1.001) || !stability)
        {
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            fprintf(debug_TEQ_SHAI_file[instance], "(biquad_gain > 1.001) || !stability => OMX_ErrorBadParameter\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
            error = OMX_ErrorBadParameter;
            break;
        }
    }
    if(p_module2 != NULL)
    {
        my_free(p_module2);
    }
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3
    fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
    fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 3

    return error;
}


static OMX_ERRORTYPE quantify_biquad_filter(t_biquad_cell_float     *p_biquad_cell_list,
                                            t_float                 gain,
                                            int                     nb_cells,
                                            t_IIR_filter_quantified *p_IIR_filter_quantified,
                                            int                     nb_bits_quantif,
                                            int                     instance)
{
    t_biquad_cell_float *p_biquad_cell;
    t_float             b0, b1, b2, b_max, coef;
    int                 i, shift;
    t_float             coef_quantif = pow2_float[nb_bits_quantif - 1] / max_float[nb_bits_quantif - 1];

    i = 0;
    for(p_biquad_cell = p_biquad_cell_list; p_biquad_cell != NULL; p_biquad_cell = p_biquad_cell->p_next)
    {
        b0     = p_biquad_cell->num.q0;
        b1     = p_biquad_cell->num.q1;
        b2     = p_biquad_cell->num.q2;
        b_max  = 0.0;
        b_max  = max(b0, b_max);
        b_max  = max(b1, b_max);
        b_max  = max(b2, b_max);
        b_max *= coef_quantif;
        b_max  = max(-b0, b_max);
        b_max  = max(-b1, b_max);
        b_max  = max(-b2, b_max);
        shift  = 0;
        if(b_max != 0.0)
        {
            coef = 1.0;
            while(b_max > 1.0)
            {
                b_max *= 0.5;
                coef  *= 0.5;
                shift++;
            }
            while(b_max <= 0.5)
            {
                b_max *= 2.0;
                coef  *= 2.0;
                shift--;
            }
            b0 *= coef;
            b1 *= coef;
            b2 *= coef;
        }
        p_IIR_filter_quantified->biquad_cell[i].b_exp = (OMX_S16) shift;
        p_IIR_filter_quantified->biquad_cell[i].b0    = float2Q31(b0,                          nb_bits_quantif);
        p_IIR_filter_quantified->biquad_cell[i].b1    = float2Q31(b1,                          nb_bits_quantif);
        p_IIR_filter_quantified->biquad_cell[i].b2    = float2Q31(b2,                          nb_bits_quantif);
        p_IIR_filter_quantified->biquad_cell[i].a1    = float2Q31(p_biquad_cell->den.q1 * 0.5, nb_bits_quantif);
        p_IIR_filter_quantified->biquad_cell[i].a2    = float2Q31(p_biquad_cell->den.q2,       nb_bits_quantif);
        i++;
        if(i > nb_cells)
        {
            return OMX_ErrorBadParameter;
        }
    }
    if(i != nb_cells)
    {
        return OMX_ErrorBadParameter;
    }

    shift = 0;
    if(gain != 0.0)
    {
        coef = gain * coef_quantif;
        while(coef > 1.0)
        {
            coef *= 0.5;
            gain *= 0.5;
            shift++;
        }
        while(coef <= 0.5)
        {
            coef *= 2.0;
            gain *= 2.0;
            shift--;
        }
    }
    p_IIR_filter_quantified->gain_exp  = (OMX_S16) shift;
    p_IIR_filter_quantified->gain_mant = float2Q31(gain, nb_bits_quantif);

    return check_biquad_stability(nb_cells, p_IIR_filter_quantified, nb_bits_quantif, instance);
}


static void free_biquad_cell_list(t_biquad_cell_float **p_p_biquad_cell_list)
{
    t_biquad_cell_float *p_biquad_cell_list = *p_p_biquad_cell_list;
    t_biquad_cell_float *p_biquad_cell, *p_biquad_cell_next;

    for(p_biquad_cell = p_biquad_cell_list; p_biquad_cell != NULL; p_biquad_cell = p_biquad_cell_next)
    {
        if(p_biquad_cell->p_complex_poles[0] != NULL)
        {
            my_free(p_biquad_cell->p_complex_poles[0]);
        }
        if(p_biquad_cell->p_complex_poles[1] != NULL)
        {
            my_free(p_biquad_cell->p_complex_poles[1]);
        }
        if(p_biquad_cell->p_real_poles[0] != NULL)
        {
            my_free(p_biquad_cell->p_real_poles[0]);
        }
        if(p_biquad_cell->p_real_poles[1] != NULL)
        {
            my_free(p_biquad_cell->p_real_poles[1]);
        }
        if(p_biquad_cell->p_complex_zeros[0] != NULL)
        {
            my_free(p_biquad_cell->p_complex_zeros[0]);
        }
        if(p_biquad_cell->p_complex_zeros[1] != NULL)
        {
            my_free(p_biquad_cell->p_complex_zeros[1]);
        }
        if(p_biquad_cell->p_real_zeros[0] != NULL)
        {
            my_free(p_biquad_cell->p_real_zeros[0]);
        }
        if(p_biquad_cell->p_real_zeros[1] != NULL)
        {
            my_free(p_biquad_cell->p_real_zeros[1]);
        }
        p_biquad_cell_next = p_biquad_cell->p_next;
        my_free(p_biquad_cell);
    }
    *p_p_biquad_cell_list = NULL;
}


static void free_IIR_filter_float(t_IIR_filter_float *p_IIR_filter)
{
    free_biquad_cell_list(&p_IIR_filter->p_biquad_cell_list);
    free_biquad_cell_list(&p_IIR_filter->p_biquad_cell_list_sorted);
}


OMX_ERRORTYPE TEQ_SHAI_compute_IIR(int                     nb_cells,
                                   t_IIR_filter_float      *p_IIR_filter,
                                   t_IIR_filter_quantified *p_IIR_filter_quantified,
                                   t_biquad_sort           biquad_sort,
                                   int                     nb_bits_quantif,
                                   int                     instance)
{
    OMX_ERRORTYPE        ret;
    t_biquad_cell_float  *p_biquad_cell;
    t_float              biquad_gain;


    if(nb_cells == 0)
    {
        p_IIR_filter_quantified->gain_exp  = (OMX_S16) 1;
        p_IIR_filter_quantified->gain_mant = (OMX_S32) 0x40000000;

        return OMX_ErrorNone;
    }

    // compute zeros & poles of each biquad cell and their distance to unit circle
    for(p_biquad_cell = p_IIR_filter->p_biquad_cell_list; p_biquad_cell != NULL; p_biquad_cell = p_biquad_cell->p_next)
    {
        ret = compute_quad_roots(&p_biquad_cell->num,
                                 p_biquad_cell->p_complex_zeros,
                                 p_biquad_cell->p_real_zeros,
                                 instance);
        if(ret != OMX_ErrorNone)
        {
            free_IIR_filter_float(p_IIR_filter);
            return ret;
        }

        ret = compute_quad_roots(&p_biquad_cell->den,
                                 p_biquad_cell->p_complex_poles,
                                 p_biquad_cell->p_real_poles,
                                 instance);
        if(ret != OMX_ErrorNone)
        {
            free_IIR_filter_float(p_IIR_filter);
            return ret;
        }
    }

    // sort biquad numerators & denominators
    ret = sort_biquad(p_IIR_filter->p_biquad_cell_list, &p_IIR_filter->p_biquad_cell_list_sorted, biquad_sort, instance);
    if(ret != OMX_ErrorNone)
    {
        return ret;
    }

    // normalize biquad cells and compute gain
    ret = normalize_biquad_cells(p_IIR_filter->p_biquad_cell_list_sorted, &biquad_gain, instance);
    if(ret != OMX_ErrorNone)
    {
        free_IIR_filter_float(p_IIR_filter);
        return ret;
    }

    // quantify biquad filter and gain
    ret = quantify_biquad_filter(p_IIR_filter->p_biquad_cell_list_sorted, biquad_gain, nb_cells, p_IIR_filter_quantified, nb_bits_quantif, instance);
    if(ret != OMX_ErrorNone)
    {
        free_IIR_filter_float(p_IIR_filter);
        return ret;
    }

#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
    {
        t_float coef_a = Pow2(-31);
        int     i;

        fprintf(debug_TEQ_SHAI_file[instance], "Equivalent floating point IIR after %d bits quantization :\n", nb_bits_quantif);
        for(i = 0; i < nb_cells; i++)
        {
            t_float coef_b = Pow2(p_IIR_filter_quantified->biquad_cell[i].b_exp - 31);
            t_float b0     = ((t_float) p_IIR_filter_quantified->biquad_cell[i].b0) * coef_b;
            t_float b1     = ((t_float) p_IIR_filter_quantified->biquad_cell[i].b1) * coef_b;
            t_float b2     = ((t_float) p_IIR_filter_quantified->biquad_cell[i].b2) * coef_b;
            t_float a1     = ((t_float) p_IIR_filter_quantified->biquad_cell[i].a1) * coef_a * 2.0;
            t_float a2     = ((t_float) p_IIR_filter_quantified->biquad_cell[i].a2) * coef_a;

            fprintf(debug_TEQ_SHAI_file[instance],
                    "(%+12.9f %+12.9f.z^-1 %+12.9f.z^-2) / (1 %+12.9f.z^-1 %+12.9f.z^-2)\n",
                    b0, b1, b2, a1, a2);
        }
        fprintf(debug_TEQ_SHAI_file[instance],
                "biquad_gain = %1.8f\n",
                ((t_float) p_IIR_filter_quantified->gain_mant) * Pow2(p_IIR_filter_quantified->gain_exp - 31));
        fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
        fflush(debug_TEQ_SHAI_file[instance]);
    }
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4

#ifdef MATLAB_TEQ_SHAI_CONFIG
    {
        int i;

        fprintf(matlab_TEQ_SHAI_file[instance], "%% matlab response curve of %d biquad cells (%d bits quantization) :\n", nb_cells, nb_bits_quantif);
        fprintf(matlab_TEQ_SHAI_file[instance], "SamplingRate           = %d;\n", (int) p_IIR_filter->nSamplingRate);
        fprintf(matlab_TEQ_SHAI_file[instance], "biquad_raw             = [");
        for(i = 0; i < nb_cells - 1; i++)
        {
            fprintf(matlab_TEQ_SHAI_file[instance], "%d %d %d %d %d %d; ",
                                                    (int) p_IIR_filter_quantified->biquad_cell[i].b_exp,
                                                    (int) p_IIR_filter_quantified->biquad_cell[i].b0,
                                                    (int) p_IIR_filter_quantified->biquad_cell[i].b1,
                                                    (int) p_IIR_filter_quantified->biquad_cell[i].b2,
                                                    (int) p_IIR_filter_quantified->biquad_cell[i].a1,
                                                    (int) p_IIR_filter_quantified->biquad_cell[i].a2);
        }
        fprintf(matlab_TEQ_SHAI_file[instance], "%d %d %d %d %d %d];\n",
                                                (int) p_IIR_filter_quantified->biquad_cell[nb_cells - 1].b_exp,
                                                (int) p_IIR_filter_quantified->biquad_cell[nb_cells - 1].b0,
                                                (int) p_IIR_filter_quantified->biquad_cell[nb_cells - 1].b1,
                                                (int) p_IIR_filter_quantified->biquad_cell[nb_cells - 1].b2,
                                                (int) p_IIR_filter_quantified->biquad_cell[nb_cells - 1].a1,
                                                (int) p_IIR_filter_quantified->biquad_cell[nb_cells - 1].a2);
        fprintf(matlab_TEQ_SHAI_file[instance], "biquad_num             = [1.0];\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "biquad_den             = [1.0];\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "for i = 1 : %d\n", nb_cells);
        fprintf(matlab_TEQ_SHAI_file[instance], "    biquad_num         = conv(biquad_num, biquad_raw(i, 2 : 4) * 2^(biquad_raw(i, 1) - 31));\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "    biquad_den         = conv(biquad_den, [1.0, biquad_raw(i, 5) / 2^30, biquad_raw(i, 6) / 2^31]);\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "end;\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "gain_mant              = %d;\n", (int) p_IIR_filter_quantified->gain_mant);
        fprintf(matlab_TEQ_SHAI_file[instance], "gain_exp               = %d;\n", (int) p_IIR_filter_quantified->gain_exp);
        fprintf(matlab_TEQ_SHAI_file[instance], "biquad_num             = biquad_num * gain_mant * 2^(gain_exp - 31);\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "N                      = 1024;\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "min_dB                 = -40.0;\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "H_biquad               = freqz(biquad_num, biquad_den, N);\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "freq_axis              = [0 : N - 1] / N * SamplingRate / 2;\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "clf(gcf);\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "subplot(1, 2, 1);\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "hold on;\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "title('quantified biquad (linear)');\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "plot(freq_axis,  abs(H_biquad), '-r');\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "subplot(1, 2, 2);\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "hold on;\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "title('quantified biquad (dB)');\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "plot(freq_axis,  max(min_dB, 20.0 * log10(abs(H_biquad))), '-r');\n");
        fprintf(matlab_TEQ_SHAI_file[instance], "%%--------------------------------------------------\n");
        fflush(matlab_TEQ_SHAI_file[instance]);
    }
#endif // MATLAB_TEQ_SHAI_CONFIG

    // my_free content of p_IIR_filter
    free_IIR_filter_float(p_IIR_filter);
    my_check_free

    return OMX_ErrorNone;
}


#define DF_DBA 100

#if (DF_DBA == 100)

static const t_float dBA_table[24000 / DF_DBA] =
{
    0.02433610, 0.15879592, 0.29258955, 0.40785139, 0.50461312, 0.58446773, 0.64961001, 0.70240921,
    0.74510023, 0.77962763, 0.80760334, 0.83032612, 0.84882613, 0.86391437, 0.87622797, 0.88626814,
    0.89443056, 0.90102919, 0.90631463, 0.91048818, 0.91371267, 0.91612070, 0.91782102, 0.91890342,
    0.91944256, 0.91950094, 0.91913122, 0.91837806, 0.91727961, 0.91586864, 0.91417346, 0.91221872,
    0.91002600, 0.90761428, 0.90500038, 0.90219928, 0.89922440, 0.89608782, 0.89280049, 0.88937236,
    0.88581253, 0.88212937, 0.87833059, 0.87442335, 0.87041431, 0.86630969, 0.86211531, 0.85783665,
    0.85347889, 0.84904691, 0.84454535, 0.83997863, 0.83535093, 0.83066627, 0.82592847, 0.82114121,
    0.81630800, 0.81143222, 0.80651710, 0.80156577, 0.79658124, 0.79156638, 0.78652400, 0.78145676,
    0.77636728, 0.77125803, 0.76613144, 0.76098983, 0.75583545, 0.75067045, 0.74549693, 0.74031691,
    0.73513233, 0.72994506, 0.72475691, 0.71956962, 0.71438487, 0.70920428, 0.70402939, 0.69886171,
    0.69370267, 0.68855366, 0.68341599, 0.67829096, 0.67317977, 0.66808360, 0.66300357, 0.65794076,
    0.65289619, 0.64787084, 0.64286566, 0.63788153, 0.63291931, 0.62797981, 0.62306379, 0.61817200,
    0.61330512, 0.60846381, 0.60364870, 0.59886038, 0.59409939, 0.58936626, 0.58466147, 0.57998550,
    0.57533877, 0.57072167, 0.56613459, 0.56157787, 0.55705183, 0.55255676, 0.54809294, 0.54366062,
    0.53926002, 0.53489134, 0.53055476, 0.52625045, 0.52197856, 0.51773919, 0.51353247, 0.50935846,
    0.50521726, 0.50110891, 0.49703345, 0.49299090, 0.48898129, 0.48500459, 0.48106080, 0.47714989,
    0.47327182, 0.46942652, 0.46561395, 0.46183403, 0.45808666, 0.45437177, 0.45068924, 0.44703896,
    0.44342082, 0.43983469, 0.43628043, 0.43275790, 0.42926696, 0.42580744, 0.42237919, 0.41898204,
    0.41561582, 0.41228036, 0.40897546, 0.40570096, 0.40245664, 0.39924233, 0.39605783, 0.39290293,
    0.38977743, 0.38668113, 0.38361381, 0.38057527, 0.37756529, 0.37458365, 0.37163014, 0.36870453,
    0.36580661, 0.36293616, 0.36009295, 0.35727675, 0.35448735, 0.35172451, 0.34898802, 0.34627763,
    0.34359314, 0.34093430, 0.33830089, 0.33569269, 0.33310947, 0.33055099, 0.32801704, 0.32550738,
    0.32302180, 0.32056006, 0.31812195, 0.31570723, 0.31331569, 0.31094710, 0.30860124, 0.30627789,
    0.30397683, 0.30169784, 0.29944072, 0.29720523, 0.29499117, 0.29279832, 0.29062647, 0.28847541,
    0.28634493, 0.28423482, 0.28214487, 0.28007489, 0.27802466, 0.27599399, 0.27398267, 0.27199050,
    0.27001729, 0.26806284, 0.26612696, 0.26420945, 0.26231012, 0.26042878, 0.25856525, 0.25671934,
    0.25489086, 0.25307963, 0.25128546, 0.24950819, 0.24774763, 0.24600360, 0.24427593, 0.24256445,
    0.24086898, 0.23918936, 0.23752541, 0.23587698, 0.23424389, 0.23262598, 0.23102309, 0.22943507,
    0.22786174, 0.22630296, 0.22475858, 0.22322842, 0.22171236, 0.22021023, 0.21872188, 0.21724718,
    0.21578596, 0.21433810, 0.21290344, 0.21148185, 0.21007318, 0.20867730, 0.20729408, 0.20592337
};

static void compute_dBA(void)
{
}

#else // (DF_DBA == 100)

static t_float dBA_table[24000 / DF_DBA];
static int     dBA_computed = 0;

static void compute_dBA(void)
{
    if(!dBA_computed)
    {
        // from http://en.wikipedia.org/wiki/A-weighting#A_2 :
        // 12200^2*f^4/((f^2+20.6^2)*sqrt((f^2+107.7^2)*(f^2+737.9^2))*(f^2+12200^2))
        //
        // compute dBA table between 0 and 24000 Hz with steps of DF_DBA Hz

        t_float f, f2;
        int     i;

        for(i = 0, f = DF_DBA / 2.0; i < (24000 / DF_DBA); i++, f += DF_DBA)
        {
            f2           = f * f;
            dBA_table[i] = 148840000.0 * f2 * f2 / ((f2 + 424.36) * Sqrt((f2 + 11599.29) * (f2 + 544496.41)) * (f2 + 148840000.0));
        }
        dBA_computed = 1;
    }
}

#endif // (DF_DBA == 100)



t_float module_avg_biquad(int compute_avg, int b_exp_int, OMX_S32 b0_int, OMX_S32 b1_int, OMX_S32 b2_int, OMX_S32 a1_int, OMX_S32 a2_int, int SamplingRate, t_float **p_p_module2, int instance)
{
    /*********************************************************************************************************************************

                     || b0 + b1.exp(-j.w) + b2.exp(-2.j.w) ||
    ||H(exp(j.w)|| = ||------------------------------------||
                     || 1  + a1.exp(-j.w) + a2.exp(-2.j.w) ||

                     || b0 + b1.cos(w) + b2.cos(2.w) -j.(b1.sin(w) + b2.sin(2.w))  ||
                   = ||----------------------------------------------------------- ||
                     || 1  + a1.cos(w) + a2.cos(2.w) -j.(a1.sin(w) + a2.sin(2.w))  ||

                     [ (b0 + b1.cos(w) + b2.cos(2.w))^2 + (b1.sin(w) + b2.sin(2.w))^2  ]^1/2
                   = [---------------------------------------------------------------- ]
                     [ (1  + a1.cos(w) + a2.cos(2.w))^2 + (a1.sin(w) + a2.sin(2.w))^2  ]

                     [ b0^2 + b1^2 + b2^2 + 2.b0.b1.cos(w) + 2.b0.b2.cos(2.w) + 2.b1.b2.(cos(w).cos(2.w) + sin(w).sin(2.w))  ]^1/2
                   = [------------------------------------------------------------------------------------------------------ ]
                     [  1   + a1^2 + a2^2 +    2.a1.cos(w) +    2.a2.cos(2.w) + 2.a1.a2.(cos(w).cos(2.w) + sin(w).sin(2.w))  ]

                     [ b0^2 + b1^2 + b2^2 + 2.b0.b1.cos(w) + 2.b0.b2.cos(2.w) + 2.b1.b2.cos(w)  ]^1/2
                   = [------------------------------------------------------------------------- ]
                     [  1   + a1^2 + a2^2 +    2.a1.cos(w) +    2.a2.cos(2.w) + 2.a1.a2.cos(w)  ]

                     [ b0^2 + b1^2 + b2^2 + 2.b1.(b0 + b2).cos(w) + 2.b0.b2.cos(2.w)  ]^1/2
                   = [--------------------------------------------------------------- ]
                     [  1   + a1^2 + a2^2 + 2.a1.( 1 + a2).cos(w) +    2.a2.cos(2.w)  ]

    *********************************************************************************************************************************/
    int     i, j;
    t_float cos1, cos2, f_dBA, df, f, sum_weight, module_avg;
    t_float b0, b1, b2, a1, a2, t0, t1, t2, t3, t4, t5;
    t_float *p_module2;


    p_module2 = *p_p_module2;
    if(compute_avg)
    {
        if(p_module2 == NULL)
        {
            return 1.0;
        }

        compute_dBA();
        f_dBA      = DF_DBA;
        df         = ((t_float) SamplingRate) / ((t_float) COS_TABLE_SIZE);
        f          = 0.0;
        sum_weight = 0.0;
        module_avg = 0.0;
        for(i = 0, j = 0; i < (COS_TABLE_SIZE / 2); i++)
        {
            module_avg += dBA_table[j] * Sqrt(p_module2[i]);
            sum_weight += dBA_table[j];
            f          += df;
            if((f > f_dBA) && (f_dBA < 24000.0))
            {
                j++;
                f_dBA += DF_DBA;
            }
        }
        module_avg /= sum_weight;
        my_free(p_module2);
        *p_p_module2 = NULL;

        return module_avg;
    }
    else
    {
        if(p_module2 == NULL)
        {
            p_module2 = (t_float *) my_malloc((COS_TABLE_SIZE / 2) * sizeof(t_float));
            *p_p_module2 = p_module2;
            if(p_module2 == NULL)
            {
                return -1.0;
            }
            for(i = 0; i < (COS_TABLE_SIZE / 2); i++)
            {
                p_module2[i] = 1.0;
            }
        }

        b2 = (b_exp_int >= 31 ? ((t_float) (1LL << (b_exp_int - 31))) : 1.0 / ((t_float) (1LL << (31 - b_exp_int))));
        b0 = ((t_float) b0_int) * b2;
        b1 = ((t_float) b1_int) * b2;
        b2 = ((t_float) b2_int) * b2;
        a1 = ((t_float) a1_int) / 1073741824.0;
        a2 = ((t_float) a2_int) / 2147483648.0;
        t0 = b0 * b0 + b1 * b1 + b2 * b2;
        t1 = 2.0 * b1 * (b0 + b2);
        t2 = 2.0 * b0 * b2;
        t3 = 1.0 + a1 * a1 + a2 * a2;
        t4 = 2.0 * a1 * (1.0 + a2);
        t5 = 2.0 * a2;
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 5
        fprintf(debug_TEQ_SHAI_file[instance], "module_avg_biquad : b0=%1.8f\n", b0);
        fprintf(debug_TEQ_SHAI_file[instance], "module_avg_biquad : b1=%1.8f\n", b1);
        fprintf(debug_TEQ_SHAI_file[instance], "module_avg_biquad : b2=%1.8f\n", b2);
        fprintf(debug_TEQ_SHAI_file[instance], "module_avg_biquad : a1=%1.8f\n", a1);
        fprintf(debug_TEQ_SHAI_file[instance], "module_avg_biquad : a2=%1.8f\n", a2);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 5
        for(i = 0; i < (COS_TABLE_SIZE / 2); i++)
        {
            cos1          = cos_table[i];       // modulo is useless (cos_table size won't be exceeded)
            cos2          = cos_table[i * 2];   //
            p_module2[i] *= (t0 + t1 * cos1 + t2 * cos2) / (t3 + t4 * cos1 + t5 * cos2);
        }

        return 0.0;
    }
}


t_float module_avg_FIR(int nb_coefs, int coef_offset, OMX_S32 *p_coef, int SamplingRate)
{
    t_float f_dBA, df, f, sum_weight, module_avg;
    int     i, j, k;


    if(nb_coefs > 0)
    {
        compute_dBA();
        nb_coefs  *= coef_offset;
        f_dBA      = DF_DBA;
        df         = ((t_float) SamplingRate) / ((t_float) COS_TABLE_SIZE);
        f          = 0.0;
        sum_weight = 0.0;
        module_avg = 0.0;
        for(i = 0, k = 0; i < (COS_TABLE_SIZE / 2); i++)
        {
            t_float coef, mod_re, mod_im, mod2;
            int     k_cos, k_sin;

            k_cos  = 0;
            mod_re = 0.0;
            mod_im = 0.0;
            for(j = 0; j < nb_coefs; j += coef_offset)
            {
                k_sin   = (k_cos + 3 * COS_TABLE_SIZE / 4) % COS_TABLE_SIZE;
                coef    = ((t_float) p_coef[j]);
                mod_re += cos_table[k_cos] * coef;
                mod_im += cos_table[k_sin] * coef;
                k_cos   = (k_cos + i) % COS_TABLE_SIZE;
            }
            mod_re     /= 2147483648.0;    // because coef are Q31
            mod_im     /= 2147483648.0;    //
            mod2        = mod_re * mod_re + mod_im * mod_im;
            module_avg += dBA_table[k] * Sqrt(mod2);
            sum_weight += dBA_table[k];
            f          += df;
            if((f > f_dBA) && (f_dBA < 24000.0))
            {
                k++;
                f_dBA += DF_DBA;
            }
        }
        module_avg /= sum_weight;
    }
    else
    {
        module_avg = 1.0;
    }

    return module_avg;
}
